// Code generated by mockery v2.53.0. DO NOT EDIT.

package mockcasbin

import (
	effector "github.com/casbin/casbin/v2/effector"
	govaluate "github.com/casbin/govaluate"

	mock "github.com/stretchr/testify/mock"

	model "github.com/casbin/casbin/v2/model"

	persist "github.com/casbin/casbin/v2/persist"

	rbac "github.com/casbin/casbin/v2/rbac"
)

// MockIEnforcer is an autogenerated mock type for the IEnforcer type
type MockIEnforcer struct {
	mock.Mock
}

type MockIEnforcer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIEnforcer) EXPECT() *MockIEnforcer_Expecter {
	return &MockIEnforcer_Expecter{mock: &_m.Mock}
}

// AddFunction provides a mock function with given fields: name, function
func (_m *MockIEnforcer) AddFunction(name string, function govaluate.ExpressionFunction) {
	_m.Called(name, function)
}

// MockIEnforcer_AddFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFunction'
type MockIEnforcer_AddFunction_Call struct {
	*mock.Call
}

// AddFunction is a helper method to define mock.On call
//   - name string
//   - function govaluate.ExpressionFunction
func (_e *MockIEnforcer_Expecter) AddFunction(name interface{}, function interface{}) *MockIEnforcer_AddFunction_Call {
	return &MockIEnforcer_AddFunction_Call{Call: _e.mock.On("AddFunction", name, function)}
}

func (_c *MockIEnforcer_AddFunction_Call) Run(run func(name string, function govaluate.ExpressionFunction)) *MockIEnforcer_AddFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(govaluate.ExpressionFunction))
	})
	return _c
}

func (_c *MockIEnforcer_AddFunction_Call) Return() *MockIEnforcer_AddFunction_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_AddFunction_Call) RunAndReturn(run func(string, govaluate.ExpressionFunction)) *MockIEnforcer_AddFunction_Call {
	_c.Run(run)
	return _c
}

// AddGroupingPolicies provides a mock function with given fields: rules
func (_m *MockIEnforcer) AddGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPolicies'
type MockIEnforcer_AddGroupingPolicies_Call struct {
	*mock.Call
}

// AddGroupingPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddGroupingPolicies(rules interface{}) *MockIEnforcer_AddGroupingPolicies_Call {
	return &MockIEnforcer_AddGroupingPolicies_Call{Call: _e.mock.On("AddGroupingPolicies", rules)}
}

func (_c *MockIEnforcer_AddGroupingPolicies_Call) Run(run func(rules [][]string)) *MockIEnforcer_AddGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddGroupingPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_AddGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupingPoliciesEx provides a mock function with given fields: rules
func (_m *MockIEnforcer) AddGroupingPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddGroupingPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPoliciesEx'
type MockIEnforcer_AddGroupingPoliciesEx_Call struct {
	*mock.Call
}

// AddGroupingPoliciesEx is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddGroupingPoliciesEx(rules interface{}) *MockIEnforcer_AddGroupingPoliciesEx_Call {
	return &MockIEnforcer_AddGroupingPoliciesEx_Call{Call: _e.mock.On("AddGroupingPoliciesEx", rules)}
}

func (_c *MockIEnforcer_AddGroupingPoliciesEx_Call) Run(run func(rules [][]string)) *MockIEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddGroupingPoliciesEx_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddGroupingPoliciesEx_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_AddGroupingPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupingPolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) AddGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupingPolicy'
type MockIEnforcer_AddGroupingPolicy_Call struct {
	*mock.Call
}

// AddGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) AddGroupingPolicy(params ...interface{}) *MockIEnforcer_AddGroupingPolicy_Call {
	return &MockIEnforcer_AddGroupingPolicy_Call{Call: _e.mock.On("AddGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_AddGroupingPolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_AddGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_AddGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) AddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPolicies'
type MockIEnforcer_AddNamedGroupingPolicies_Call struct {
	*mock.Call
}

// AddNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddNamedGroupingPolicies(ptype interface{}, rules interface{}) *MockIEnforcer_AddNamedGroupingPolicies_Call {
	return &MockIEnforcer_AddNamedGroupingPolicies_Call{Call: _e.mock.On("AddNamedGroupingPolicies", ptype, rules)}
}

func (_c *MockIEnforcer_AddNamedGroupingPolicies_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_AddNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedGroupingPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPoliciesEx'
type MockIEnforcer_AddNamedGroupingPoliciesEx_Call struct {
	*mock.Call
}

// AddNamedGroupingPoliciesEx is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddNamedGroupingPoliciesEx(ptype interface{}, rules interface{}) *MockIEnforcer_AddNamedGroupingPoliciesEx_Call {
	return &MockIEnforcer_AddNamedGroupingPoliciesEx_Call{Call: _e.mock.On("AddNamedGroupingPoliciesEx", ptype, rules)}
}

func (_c *MockIEnforcer_AddNamedGroupingPoliciesEx_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPoliciesEx_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPoliciesEx_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_AddNamedGroupingPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) AddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedGroupingPolicy'
type MockIEnforcer_AddNamedGroupingPolicy_Call struct {
	*mock.Call
}

// AddNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) AddNamedGroupingPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_AddNamedGroupingPolicy_Call {
	return &MockIEnforcer_AddNamedGroupingPolicy_Call{Call: _e.mock.On("AddNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_AddNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_AddNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) AddNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPolicies'
type MockIEnforcer_AddNamedPolicies_Call struct {
	*mock.Call
}

// AddNamedPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddNamedPolicies(ptype interface{}, rules interface{}) *MockIEnforcer_AddNamedPolicies_Call {
	return &MockIEnforcer_AddNamedPolicies_Call{Call: _e.mock.On("AddNamedPolicies", ptype, rules)}
}

func (_c *MockIEnforcer_AddNamedPolicies_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_AddNamedPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_AddNamedPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPoliciesEx provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPoliciesEx'
type MockIEnforcer_AddNamedPoliciesEx_Call struct {
	*mock.Call
}

// AddNamedPoliciesEx is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddNamedPoliciesEx(ptype interface{}, rules interface{}) *MockIEnforcer_AddNamedPoliciesEx_Call {
	return &MockIEnforcer_AddNamedPoliciesEx_Call{Call: _e.mock.On("AddNamedPoliciesEx", ptype, rules)}
}

func (_c *MockIEnforcer_AddNamedPoliciesEx_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedPoliciesEx_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedPoliciesEx_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_AddNamedPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddNamedPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) AddNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNamedPolicy'
type MockIEnforcer_AddNamedPolicy_Call struct {
	*mock.Call
}

// AddNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) AddNamedPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_AddNamedPolicy_Call {
	return &MockIEnforcer_AddNamedPolicy_Call{Call: _e.mock.On("AddNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_AddNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_AddNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddNamedPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_AddNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddPermissionForUser provides a mock function with given fields: user, permission
func (_m *MockIEnforcer) AddPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddPermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPermissionForUser'
type MockIEnforcer_AddPermissionForUser_Call struct {
	*mock.Call
}

// AddPermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *MockIEnforcer_Expecter) AddPermissionForUser(user interface{}, permission ...interface{}) *MockIEnforcer_AddPermissionForUser_Call {
	return &MockIEnforcer_AddPermissionForUser_Call{Call: _e.mock.On("AddPermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *MockIEnforcer_AddPermissionForUser_Call) Run(run func(user string, permission ...string)) *MockIEnforcer_AddPermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddPermissionForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddPermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddPermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *MockIEnforcer_AddPermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddPermissionsForUser provides a mock function with given fields: user, permissions
func (_m *MockIEnforcer) AddPermissionsForUser(user string, permissions ...[]string) (bool, error) {
	_va := make([]interface{}, len(permissions))
	for _i := range permissions {
		_va[_i] = permissions[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...[]string) (bool, error)); ok {
		return rf(user, permissions...)
	}
	if rf, ok := ret.Get(0).(func(string, ...[]string) bool); ok {
		r0 = rf(user, permissions...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...[]string) error); ok {
		r1 = rf(user, permissions...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPermissionsForUser'
type MockIEnforcer_AddPermissionsForUser_Call struct {
	*mock.Call
}

// AddPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - permissions ...[]string
func (_e *MockIEnforcer_Expecter) AddPermissionsForUser(user interface{}, permissions ...interface{}) *MockIEnforcer_AddPermissionsForUser_Call {
	return &MockIEnforcer_AddPermissionsForUser_Call{Call: _e.mock.On("AddPermissionsForUser",
		append([]interface{}{user}, permissions...)...)}
}

func (_c *MockIEnforcer_AddPermissionsForUser_Call) Run(run func(user string, permissions ...[]string)) *MockIEnforcer_AddPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([][]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.([]string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddPermissionsForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddPermissionsForUser_Call) RunAndReturn(run func(string, ...[]string) (bool, error)) *MockIEnforcer_AddPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddPolicies provides a mock function with given fields: rules
func (_m *MockIEnforcer) AddPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPolicies'
type MockIEnforcer_AddPolicies_Call struct {
	*mock.Call
}

// AddPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddPolicies(rules interface{}) *MockIEnforcer_AddPolicies_Call {
	return &MockIEnforcer_AddPolicies_Call{Call: _e.mock.On("AddPolicies", rules)}
}

func (_c *MockIEnforcer_AddPolicies_Call) Run(run func(rules [][]string)) *MockIEnforcer_AddPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_AddPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// AddPoliciesEx provides a mock function with given fields: rules
func (_m *MockIEnforcer) AddPoliciesEx(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for AddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPoliciesEx'
type MockIEnforcer_AddPoliciesEx_Call struct {
	*mock.Call
}

// AddPoliciesEx is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) AddPoliciesEx(rules interface{}) *MockIEnforcer_AddPoliciesEx_Call {
	return &MockIEnforcer_AddPoliciesEx_Call{Call: _e.mock.On("AddPoliciesEx", rules)}
}

func (_c *MockIEnforcer_AddPoliciesEx_Call) Run(run func(rules [][]string)) *MockIEnforcer_AddPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_AddPoliciesEx_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddPoliciesEx_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_AddPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// AddPolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) AddPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPolicy'
type MockIEnforcer_AddPolicy_Call struct {
	*mock.Call
}

// AddPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) AddPolicy(params ...interface{}) *MockIEnforcer_AddPolicy_Call {
	return &MockIEnforcer_AddPolicy_Call{Call: _e.mock.On("AddPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_AddPolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_AddPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_AddPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// AddRoleForUser provides a mock function with given fields: user, role, domain
func (_m *MockIEnforcer) AddRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRoleForUser'
type MockIEnforcer_AddRoleForUser_Call struct {
	*mock.Call
}

// AddRoleForUser is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) AddRoleForUser(user interface{}, role interface{}, domain ...interface{}) *MockIEnforcer_AddRoleForUser_Call {
	return &MockIEnforcer_AddRoleForUser_Call{Call: _e.mock.On("AddRoleForUser",
		append([]interface{}{user, role}, domain...)...)}
}

func (_c *MockIEnforcer_AddRoleForUser_Call) Run(run func(user string, role string, domain ...string)) *MockIEnforcer_AddRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_AddRoleForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *MockIEnforcer_AddRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *MockIEnforcer) AddRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for AddRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_AddRoleForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRoleForUserInDomain'
type MockIEnforcer_AddRoleForUserInDomain_Call struct {
	*mock.Call
}

// AddRoleForUserInDomain is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain string
func (_e *MockIEnforcer_Expecter) AddRoleForUserInDomain(user interface{}, role interface{}, domain interface{}) *MockIEnforcer_AddRoleForUserInDomain_Call {
	return &MockIEnforcer_AddRoleForUserInDomain_Call{Call: _e.mock.On("AddRoleForUserInDomain", user, role, domain)}
}

func (_c *MockIEnforcer_AddRoleForUserInDomain_Call) Run(run func(user string, role string, domain string)) *MockIEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockIEnforcer_AddRoleForUserInDomain_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_AddRoleForUserInDomain_Call) RunAndReturn(run func(string, string, string) (bool, error)) *MockIEnforcer_AddRoleForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// BatchEnforce provides a mock function with given fields: requests
func (_m *MockIEnforcer) BatchEnforce(requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforce")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]interface{}) ([]bool, error)); ok {
		return rf(requests)
	}
	if rf, ok := ret.Get(0).(func([][]interface{}) []bool); ok {
		r0 = rf(requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func([][]interface{}) error); ok {
		r1 = rf(requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_BatchEnforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchEnforce'
type MockIEnforcer_BatchEnforce_Call struct {
	*mock.Call
}

// BatchEnforce is a helper method to define mock.On call
//   - requests [][]interface{}
func (_e *MockIEnforcer_Expecter) BatchEnforce(requests interface{}) *MockIEnforcer_BatchEnforce_Call {
	return &MockIEnforcer_BatchEnforce_Call{Call: _e.mock.On("BatchEnforce", requests)}
}

func (_c *MockIEnforcer_BatchEnforce_Call) Run(run func(requests [][]interface{})) *MockIEnforcer_BatchEnforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]interface{}))
	})
	return _c
}

func (_c *MockIEnforcer_BatchEnforce_Call) Return(_a0 []bool, _a1 error) *MockIEnforcer_BatchEnforce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_BatchEnforce_Call) RunAndReturn(run func([][]interface{}) ([]bool, error)) *MockIEnforcer_BatchEnforce_Call {
	_c.Call.Return(run)
	return _c
}

// BatchEnforceWithMatcher provides a mock function with given fields: matcher, requests
func (_m *MockIEnforcer) BatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error) {
	ret := _m.Called(matcher, requests)

	if len(ret) == 0 {
		panic("no return value specified for BatchEnforceWithMatcher")
	}

	var r0 []bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) ([]bool, error)); ok {
		return rf(matcher, requests)
	}
	if rf, ok := ret.Get(0).(func(string, [][]interface{}) []bool); ok {
		r0 = rf(matcher, requests)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(string, [][]interface{}) error); ok {
		r1 = rf(matcher, requests)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_BatchEnforceWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchEnforceWithMatcher'
type MockIEnforcer_BatchEnforceWithMatcher_Call struct {
	*mock.Call
}

// BatchEnforceWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - requests [][]interface{}
func (_e *MockIEnforcer_Expecter) BatchEnforceWithMatcher(matcher interface{}, requests interface{}) *MockIEnforcer_BatchEnforceWithMatcher_Call {
	return &MockIEnforcer_BatchEnforceWithMatcher_Call{Call: _e.mock.On("BatchEnforceWithMatcher", matcher, requests)}
}

func (_c *MockIEnforcer_BatchEnforceWithMatcher_Call) Run(run func(matcher string, requests [][]interface{})) *MockIEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]interface{}))
	})
	return _c
}

func (_c *MockIEnforcer_BatchEnforceWithMatcher_Call) Return(_a0 []bool, _a1 error) *MockIEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_BatchEnforceWithMatcher_Call) RunAndReturn(run func(string, [][]interface{}) ([]bool, error)) *MockIEnforcer_BatchEnforceWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// BuildRoleLinks provides a mock function with no fields
func (_m *MockIEnforcer) BuildRoleLinks() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BuildRoleLinks")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_BuildRoleLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildRoleLinks'
type MockIEnforcer_BuildRoleLinks_Call struct {
	*mock.Call
}

// BuildRoleLinks is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) BuildRoleLinks() *MockIEnforcer_BuildRoleLinks_Call {
	return &MockIEnforcer_BuildRoleLinks_Call{Call: _e.mock.On("BuildRoleLinks")}
}

func (_c *MockIEnforcer_BuildRoleLinks_Call) Run(run func()) *MockIEnforcer_BuildRoleLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_BuildRoleLinks_Call) Return(_a0 error) *MockIEnforcer_BuildRoleLinks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_BuildRoleLinks_Call) RunAndReturn(run func() error) *MockIEnforcer_BuildRoleLinks_Call {
	_c.Call.Return(run)
	return _c
}

// ClearPolicy provides a mock function with no fields
func (_m *MockIEnforcer) ClearPolicy() {
	_m.Called()
}

// MockIEnforcer_ClearPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearPolicy'
type MockIEnforcer_ClearPolicy_Call struct {
	*mock.Call
}

// ClearPolicy is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) ClearPolicy() *MockIEnforcer_ClearPolicy_Call {
	return &MockIEnforcer_ClearPolicy_Call{Call: _e.mock.On("ClearPolicy")}
}

func (_c *MockIEnforcer_ClearPolicy_Call) Run(run func()) *MockIEnforcer_ClearPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_ClearPolicy_Call) Return() *MockIEnforcer_ClearPolicy_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_ClearPolicy_Call) RunAndReturn(run func()) *MockIEnforcer_ClearPolicy_Call {
	_c.Run(run)
	return _c
}

// DeleteAllUsersByDomain provides a mock function with given fields: domain
func (_m *MockIEnforcer) DeleteAllUsersByDomain(domain string) (bool, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllUsersByDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteAllUsersByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllUsersByDomain'
type MockIEnforcer_DeleteAllUsersByDomain_Call struct {
	*mock.Call
}

// DeleteAllUsersByDomain is a helper method to define mock.On call
//   - domain string
func (_e *MockIEnforcer_Expecter) DeleteAllUsersByDomain(domain interface{}) *MockIEnforcer_DeleteAllUsersByDomain_Call {
	return &MockIEnforcer_DeleteAllUsersByDomain_Call{Call: _e.mock.On("DeleteAllUsersByDomain", domain)}
}

func (_c *MockIEnforcer_DeleteAllUsersByDomain_Call) Run(run func(domain string)) *MockIEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeleteAllUsersByDomain_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteAllUsersByDomain_Call) RunAndReturn(run func(string) (bool, error)) *MockIEnforcer_DeleteAllUsersByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDomains provides a mock function with given fields: domains
func (_m *MockIEnforcer) DeleteDomains(domains ...string) (bool, error) {
	_va := make([]interface{}, len(domains))
	for _i := range domains {
		_va[_i] = domains[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDomains")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(domains...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(domains...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(domains...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteDomains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDomains'
type MockIEnforcer_DeleteDomains_Call struct {
	*mock.Call
}

// DeleteDomains is a helper method to define mock.On call
//   - domains ...string
func (_e *MockIEnforcer_Expecter) DeleteDomains(domains ...interface{}) *MockIEnforcer_DeleteDomains_Call {
	return &MockIEnforcer_DeleteDomains_Call{Call: _e.mock.On("DeleteDomains",
		append([]interface{}{}, domains...)...)}
}

func (_c *MockIEnforcer_DeleteDomains_Call) Run(run func(domains ...string)) *MockIEnforcer_DeleteDomains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_DeleteDomains_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteDomains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteDomains_Call) RunAndReturn(run func(...string) (bool, error)) *MockIEnforcer_DeleteDomains_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermission provides a mock function with given fields: permission
func (_m *MockIEnforcer) DeletePermission(permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) (bool, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) bool); ok {
		r0 = rf(permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeletePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermission'
type MockIEnforcer_DeletePermission_Call struct {
	*mock.Call
}

// DeletePermission is a helper method to define mock.On call
//   - permission ...string
func (_e *MockIEnforcer_Expecter) DeletePermission(permission ...interface{}) *MockIEnforcer_DeletePermission_Call {
	return &MockIEnforcer_DeletePermission_Call{Call: _e.mock.On("DeletePermission",
		append([]interface{}{}, permission...)...)}
}

func (_c *MockIEnforcer_DeletePermission_Call) Run(run func(permission ...string)) *MockIEnforcer_DeletePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_DeletePermission_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeletePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeletePermission_Call) RunAndReturn(run func(...string) (bool, error)) *MockIEnforcer_DeletePermission_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermissionForUser provides a mock function with given fields: user, permission
func (_m *MockIEnforcer) DeletePermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeletePermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermissionForUser'
type MockIEnforcer_DeletePermissionForUser_Call struct {
	*mock.Call
}

// DeletePermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *MockIEnforcer_Expecter) DeletePermissionForUser(user interface{}, permission ...interface{}) *MockIEnforcer_DeletePermissionForUser_Call {
	return &MockIEnforcer_DeletePermissionForUser_Call{Call: _e.mock.On("DeletePermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *MockIEnforcer_DeletePermissionForUser_Call) Run(run func(user string, permission ...string)) *MockIEnforcer_DeletePermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_DeletePermissionForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeletePermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeletePermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *MockIEnforcer_DeletePermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermissionsForUser provides a mock function with given fields: user
func (_m *MockIEnforcer) DeletePermissionsForUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermissionsForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeletePermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermissionsForUser'
type MockIEnforcer_DeletePermissionsForUser_Call struct {
	*mock.Call
}

// DeletePermissionsForUser is a helper method to define mock.On call
//   - user string
func (_e *MockIEnforcer_Expecter) DeletePermissionsForUser(user interface{}) *MockIEnforcer_DeletePermissionsForUser_Call {
	return &MockIEnforcer_DeletePermissionsForUser_Call{Call: _e.mock.On("DeletePermissionsForUser", user)}
}

func (_c *MockIEnforcer_DeletePermissionsForUser_Call) Run(run func(user string)) *MockIEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeletePermissionsForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeletePermissionsForUser_Call) RunAndReturn(run func(string) (bool, error)) *MockIEnforcer_DeletePermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRole provides a mock function with given fields: role
func (_m *MockIEnforcer) DeleteRole(role string) (bool, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRole'
type MockIEnforcer_DeleteRole_Call struct {
	*mock.Call
}

// DeleteRole is a helper method to define mock.On call
//   - role string
func (_e *MockIEnforcer_Expecter) DeleteRole(role interface{}) *MockIEnforcer_DeleteRole_Call {
	return &MockIEnforcer_DeleteRole_Call{Call: _e.mock.On("DeleteRole", role)}
}

func (_c *MockIEnforcer_DeleteRole_Call) Run(run func(role string)) *MockIEnforcer_DeleteRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeleteRole_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteRole_Call) RunAndReturn(run func(string) (bool, error)) *MockIEnforcer_DeleteRole_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRoleForUser provides a mock function with given fields: user, role, domain
func (_m *MockIEnforcer) DeleteRoleForUser(user string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(user, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(user, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(user, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoleForUser'
type MockIEnforcer_DeleteRoleForUser_Call struct {
	*mock.Call
}

// DeleteRoleForUser is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) DeleteRoleForUser(user interface{}, role interface{}, domain ...interface{}) *MockIEnforcer_DeleteRoleForUser_Call {
	return &MockIEnforcer_DeleteRoleForUser_Call{Call: _e.mock.On("DeleteRoleForUser",
		append([]interface{}{user, role}, domain...)...)}
}

func (_c *MockIEnforcer_DeleteRoleForUser_Call) Run(run func(user string, role string, domain ...string)) *MockIEnforcer_DeleteRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_DeleteRoleForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *MockIEnforcer_DeleteRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRoleForUserInDomain provides a mock function with given fields: user, role, domain
func (_m *MockIEnforcer) DeleteRoleForUserInDomain(user string, role string, domain string) (bool, error) {
	ret := _m.Called(user, role, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoleForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(user, role, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(user, role, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(user, role, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteRoleForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoleForUserInDomain'
type MockIEnforcer_DeleteRoleForUserInDomain_Call struct {
	*mock.Call
}

// DeleteRoleForUserInDomain is a helper method to define mock.On call
//   - user string
//   - role string
//   - domain string
func (_e *MockIEnforcer_Expecter) DeleteRoleForUserInDomain(user interface{}, role interface{}, domain interface{}) *MockIEnforcer_DeleteRoleForUserInDomain_Call {
	return &MockIEnforcer_DeleteRoleForUserInDomain_Call{Call: _e.mock.On("DeleteRoleForUserInDomain", user, role, domain)}
}

func (_c *MockIEnforcer_DeleteRoleForUserInDomain_Call) Run(run func(user string, role string, domain string)) *MockIEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeleteRoleForUserInDomain_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteRoleForUserInDomain_Call) RunAndReturn(run func(string, string, string) (bool, error)) *MockIEnforcer_DeleteRoleForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRolesForUser provides a mock function with given fields: user, domain
func (_m *MockIEnforcer) DeleteRolesForUser(user string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRolesForUser'
type MockIEnforcer_DeleteRolesForUser_Call struct {
	*mock.Call
}

// DeleteRolesForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) DeleteRolesForUser(user interface{}, domain ...interface{}) *MockIEnforcer_DeleteRolesForUser_Call {
	return &MockIEnforcer_DeleteRolesForUser_Call{Call: _e.mock.On("DeleteRolesForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *MockIEnforcer_DeleteRolesForUser_Call) Run(run func(user string, domain ...string)) *MockIEnforcer_DeleteRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_DeleteRolesForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteRolesForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *MockIEnforcer_DeleteRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRolesForUserInDomain provides a mock function with given fields: user, domain
func (_m *MockIEnforcer) DeleteRolesForUserInDomain(user string, domain string) (bool, error) {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRolesForUserInDomain")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(user, domain)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(user, domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(user, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteRolesForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRolesForUserInDomain'
type MockIEnforcer_DeleteRolesForUserInDomain_Call struct {
	*mock.Call
}

// DeleteRolesForUserInDomain is a helper method to define mock.On call
//   - user string
//   - domain string
func (_e *MockIEnforcer_Expecter) DeleteRolesForUserInDomain(user interface{}, domain interface{}) *MockIEnforcer_DeleteRolesForUserInDomain_Call {
	return &MockIEnforcer_DeleteRolesForUserInDomain_Call{Call: _e.mock.On("DeleteRolesForUserInDomain", user, domain)}
}

func (_c *MockIEnforcer_DeleteRolesForUserInDomain_Call) Run(run func(user string, domain string)) *MockIEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeleteRolesForUserInDomain_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteRolesForUserInDomain_Call) RunAndReturn(run func(string, string) (bool, error)) *MockIEnforcer_DeleteRolesForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: user
func (_m *MockIEnforcer) DeleteUser(user string) (bool, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockIEnforcer_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - user string
func (_e *MockIEnforcer_Expecter) DeleteUser(user interface{}) *MockIEnforcer_DeleteUser_Call {
	return &MockIEnforcer_DeleteUser_Call{Call: _e.mock.On("DeleteUser", user)}
}

func (_c *MockIEnforcer_DeleteUser_Call) Run(run func(user string)) *MockIEnforcer_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_DeleteUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_DeleteUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_DeleteUser_Call) RunAndReturn(run func(string) (bool, error)) *MockIEnforcer_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// EnableAutoBuildRoleLinks provides a mock function with given fields: autoBuildRoleLinks
func (_m *MockIEnforcer) EnableAutoBuildRoleLinks(autoBuildRoleLinks bool) {
	_m.Called(autoBuildRoleLinks)
}

// MockIEnforcer_EnableAutoBuildRoleLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoBuildRoleLinks'
type MockIEnforcer_EnableAutoBuildRoleLinks_Call struct {
	*mock.Call
}

// EnableAutoBuildRoleLinks is a helper method to define mock.On call
//   - autoBuildRoleLinks bool
func (_e *MockIEnforcer_Expecter) EnableAutoBuildRoleLinks(autoBuildRoleLinks interface{}) *MockIEnforcer_EnableAutoBuildRoleLinks_Call {
	return &MockIEnforcer_EnableAutoBuildRoleLinks_Call{Call: _e.mock.On("EnableAutoBuildRoleLinks", autoBuildRoleLinks)}
}

func (_c *MockIEnforcer_EnableAutoBuildRoleLinks_Call) Run(run func(autoBuildRoleLinks bool)) *MockIEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockIEnforcer_EnableAutoBuildRoleLinks_Call) Return() *MockIEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_EnableAutoBuildRoleLinks_Call) RunAndReturn(run func(bool)) *MockIEnforcer_EnableAutoBuildRoleLinks_Call {
	_c.Run(run)
	return _c
}

// EnableAutoNotifyWatcher provides a mock function with given fields: enable
func (_m *MockIEnforcer) EnableAutoNotifyWatcher(enable bool) {
	_m.Called(enable)
}

// MockIEnforcer_EnableAutoNotifyWatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoNotifyWatcher'
type MockIEnforcer_EnableAutoNotifyWatcher_Call struct {
	*mock.Call
}

// EnableAutoNotifyWatcher is a helper method to define mock.On call
//   - enable bool
func (_e *MockIEnforcer_Expecter) EnableAutoNotifyWatcher(enable interface{}) *MockIEnforcer_EnableAutoNotifyWatcher_Call {
	return &MockIEnforcer_EnableAutoNotifyWatcher_Call{Call: _e.mock.On("EnableAutoNotifyWatcher", enable)}
}

func (_c *MockIEnforcer_EnableAutoNotifyWatcher_Call) Run(run func(enable bool)) *MockIEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockIEnforcer_EnableAutoNotifyWatcher_Call) Return() *MockIEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_EnableAutoNotifyWatcher_Call) RunAndReturn(run func(bool)) *MockIEnforcer_EnableAutoNotifyWatcher_Call {
	_c.Run(run)
	return _c
}

// EnableAutoSave provides a mock function with given fields: autoSave
func (_m *MockIEnforcer) EnableAutoSave(autoSave bool) {
	_m.Called(autoSave)
}

// MockIEnforcer_EnableAutoSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAutoSave'
type MockIEnforcer_EnableAutoSave_Call struct {
	*mock.Call
}

// EnableAutoSave is a helper method to define mock.On call
//   - autoSave bool
func (_e *MockIEnforcer_Expecter) EnableAutoSave(autoSave interface{}) *MockIEnforcer_EnableAutoSave_Call {
	return &MockIEnforcer_EnableAutoSave_Call{Call: _e.mock.On("EnableAutoSave", autoSave)}
}

func (_c *MockIEnforcer_EnableAutoSave_Call) Run(run func(autoSave bool)) *MockIEnforcer_EnableAutoSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockIEnforcer_EnableAutoSave_Call) Return() *MockIEnforcer_EnableAutoSave_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_EnableAutoSave_Call) RunAndReturn(run func(bool)) *MockIEnforcer_EnableAutoSave_Call {
	_c.Run(run)
	return _c
}

// EnableEnforce provides a mock function with given fields: enable
func (_m *MockIEnforcer) EnableEnforce(enable bool) {
	_m.Called(enable)
}

// MockIEnforcer_EnableEnforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableEnforce'
type MockIEnforcer_EnableEnforce_Call struct {
	*mock.Call
}

// EnableEnforce is a helper method to define mock.On call
//   - enable bool
func (_e *MockIEnforcer_Expecter) EnableEnforce(enable interface{}) *MockIEnforcer_EnableEnforce_Call {
	return &MockIEnforcer_EnableEnforce_Call{Call: _e.mock.On("EnableEnforce", enable)}
}

func (_c *MockIEnforcer_EnableEnforce_Call) Run(run func(enable bool)) *MockIEnforcer_EnableEnforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockIEnforcer_EnableEnforce_Call) Return() *MockIEnforcer_EnableEnforce_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_EnableEnforce_Call) RunAndReturn(run func(bool)) *MockIEnforcer_EnableEnforce_Call {
	_c.Run(run)
	return _c
}

// EnableLog provides a mock function with given fields: enable
func (_m *MockIEnforcer) EnableLog(enable bool) {
	_m.Called(enable)
}

// MockIEnforcer_EnableLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableLog'
type MockIEnforcer_EnableLog_Call struct {
	*mock.Call
}

// EnableLog is a helper method to define mock.On call
//   - enable bool
func (_e *MockIEnforcer_Expecter) EnableLog(enable interface{}) *MockIEnforcer_EnableLog_Call {
	return &MockIEnforcer_EnableLog_Call{Call: _e.mock.On("EnableLog", enable)}
}

func (_c *MockIEnforcer_EnableLog_Call) Run(run func(enable bool)) *MockIEnforcer_EnableLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *MockIEnforcer_EnableLog_Call) Return() *MockIEnforcer_EnableLog_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_EnableLog_Call) RunAndReturn(run func(bool)) *MockIEnforcer_EnableLog_Call {
	_c.Run(run)
	return _c
}

// Enforce provides a mock function with given fields: rvals
func (_m *MockIEnforcer) Enforce(rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Enforce")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_Enforce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enforce'
type MockIEnforcer_Enforce_Call struct {
	*mock.Call
}

// Enforce is a helper method to define mock.On call
//   - rvals ...interface{}
func (_e *MockIEnforcer_Expecter) Enforce(rvals ...interface{}) *MockIEnforcer_Enforce_Call {
	return &MockIEnforcer_Enforce_Call{Call: _e.mock.On("Enforce",
		append([]interface{}{}, rvals...)...)}
}

func (_c *MockIEnforcer_Enforce_Call) Run(run func(rvals ...interface{})) *MockIEnforcer_Enforce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_Enforce_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_Enforce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_Enforce_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_Enforce_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceEx provides a mock function with given fields: rvals
func (_m *MockIEnforcer) EnforceEx(rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceEx")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, []string, error)); ok {
		return rf(rvals...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) []string); ok {
		r1 = rf(rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(...interface{}) error); ok {
		r2 = rf(rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockIEnforcer_EnforceEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceEx'
type MockIEnforcer_EnforceEx_Call struct {
	*mock.Call
}

// EnforceEx is a helper method to define mock.On call
//   - rvals ...interface{}
func (_e *MockIEnforcer_Expecter) EnforceEx(rvals ...interface{}) *MockIEnforcer_EnforceEx_Call {
	return &MockIEnforcer_EnforceEx_Call{Call: _e.mock.On("EnforceEx",
		append([]interface{}{}, rvals...)...)}
}

func (_c *MockIEnforcer_EnforceEx_Call) Run(run func(rvals ...interface{})) *MockIEnforcer_EnforceEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_EnforceEx_Call) Return(_a0 bool, _a1 []string, _a2 error) *MockIEnforcer_EnforceEx_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockIEnforcer_EnforceEx_Call) RunAndReturn(run func(...interface{}) (bool, []string, error)) *MockIEnforcer_EnforceEx_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceExWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *MockIEnforcer) EnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceExWithMatcher")
	}

	var r0 bool
	var r1 []string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, []string, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) []string); ok {
		r1 = rf(matcher, rvals...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	if rf, ok := ret.Get(2).(func(string, ...interface{}) error); ok {
		r2 = rf(matcher, rvals...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockIEnforcer_EnforceExWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceExWithMatcher'
type MockIEnforcer_EnforceExWithMatcher_Call struct {
	*mock.Call
}

// EnforceExWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - rvals ...interface{}
func (_e *MockIEnforcer_Expecter) EnforceExWithMatcher(matcher interface{}, rvals ...interface{}) *MockIEnforcer_EnforceExWithMatcher_Call {
	return &MockIEnforcer_EnforceExWithMatcher_Call{Call: _e.mock.On("EnforceExWithMatcher",
		append([]interface{}{matcher}, rvals...)...)}
}

func (_c *MockIEnforcer_EnforceExWithMatcher_Call) Run(run func(matcher string, rvals ...interface{})) *MockIEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_EnforceExWithMatcher_Call) Return(_a0 bool, _a1 []string, _a2 error) *MockIEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockIEnforcer_EnforceExWithMatcher_Call) RunAndReturn(run func(string, ...interface{}) (bool, []string, error)) *MockIEnforcer_EnforceExWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// EnforceWithMatcher provides a mock function with given fields: matcher, rvals
func (_m *MockIEnforcer) EnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, matcher)
	_ca = append(_ca, rvals...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnforceWithMatcher")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(matcher, rvals...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(matcher, rvals...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(matcher, rvals...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_EnforceWithMatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnforceWithMatcher'
type MockIEnforcer_EnforceWithMatcher_Call struct {
	*mock.Call
}

// EnforceWithMatcher is a helper method to define mock.On call
//   - matcher string
//   - rvals ...interface{}
func (_e *MockIEnforcer_Expecter) EnforceWithMatcher(matcher interface{}, rvals ...interface{}) *MockIEnforcer_EnforceWithMatcher_Call {
	return &MockIEnforcer_EnforceWithMatcher_Call{Call: _e.mock.On("EnforceWithMatcher",
		append([]interface{}{matcher}, rvals...)...)}
}

func (_c *MockIEnforcer_EnforceWithMatcher_Call) Run(run func(matcher string, rvals ...interface{})) *MockIEnforcer_EnforceWithMatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_EnforceWithMatcher_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_EnforceWithMatcher_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_EnforceWithMatcher_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_EnforceWithMatcher_Call {
	_c.Call.Return(run)
	return _c
}

// GetAdapter provides a mock function with no fields
func (_m *MockIEnforcer) GetAdapter() persist.Adapter {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAdapter")
	}

	var r0 persist.Adapter
	if rf, ok := ret.Get(0).(func() persist.Adapter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persist.Adapter)
		}
	}

	return r0
}

// MockIEnforcer_GetAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAdapter'
type MockIEnforcer_GetAdapter_Call struct {
	*mock.Call
}

// GetAdapter is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAdapter() *MockIEnforcer_GetAdapter_Call {
	return &MockIEnforcer_GetAdapter_Call{Call: _e.mock.On("GetAdapter")}
}

func (_c *MockIEnforcer_GetAdapter_Call) Run(run func()) *MockIEnforcer_GetAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAdapter_Call) Return(_a0 persist.Adapter) *MockIEnforcer_GetAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetAdapter_Call) RunAndReturn(run func() persist.Adapter) *MockIEnforcer_GetAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllActions provides a mock function with no fields
func (_m *MockIEnforcer) GetAllActions() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllActions'
type MockIEnforcer_GetAllActions_Call struct {
	*mock.Call
}

// GetAllActions is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAllActions() *MockIEnforcer_GetAllActions_Call {
	return &MockIEnforcer_GetAllActions_Call{Call: _e.mock.On("GetAllActions")}
}

func (_c *MockIEnforcer_GetAllActions_Call) Run(run func()) *MockIEnforcer_GetAllActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAllActions_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllActions_Call) RunAndReturn(run func() ([]string, error)) *MockIEnforcer_GetAllActions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllDomains provides a mock function with no fields
func (_m *MockIEnforcer) GetAllDomains() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllDomains")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllDomains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllDomains'
type MockIEnforcer_GetAllDomains_Call struct {
	*mock.Call
}

// GetAllDomains is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAllDomains() *MockIEnforcer_GetAllDomains_Call {
	return &MockIEnforcer_GetAllDomains_Call{Call: _e.mock.On("GetAllDomains")}
}

func (_c *MockIEnforcer_GetAllDomains_Call) Run(run func()) *MockIEnforcer_GetAllDomains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAllDomains_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllDomains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllDomains_Call) RunAndReturn(run func() ([]string, error)) *MockIEnforcer_GetAllDomains_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedActions provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetAllNamedActions(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedActions")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllNamedActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedActions'
type MockIEnforcer_GetAllNamedActions_Call struct {
	*mock.Call
}

// GetAllNamedActions is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetAllNamedActions(ptype interface{}) *MockIEnforcer_GetAllNamedActions_Call {
	return &MockIEnforcer_GetAllNamedActions_Call{Call: _e.mock.On("GetAllNamedActions", ptype)}
}

func (_c *MockIEnforcer_GetAllNamedActions_Call) Run(run func(ptype string)) *MockIEnforcer_GetAllNamedActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllNamedActions_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllNamedActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllNamedActions_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllNamedActions_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedObjects provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetAllNamedObjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllNamedObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedObjects'
type MockIEnforcer_GetAllNamedObjects_Call struct {
	*mock.Call
}

// GetAllNamedObjects is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetAllNamedObjects(ptype interface{}) *MockIEnforcer_GetAllNamedObjects_Call {
	return &MockIEnforcer_GetAllNamedObjects_Call{Call: _e.mock.On("GetAllNamedObjects", ptype)}
}

func (_c *MockIEnforcer_GetAllNamedObjects_Call) Run(run func(ptype string)) *MockIEnforcer_GetAllNamedObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllNamedObjects_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllNamedObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllNamedObjects_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllNamedObjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedRoles provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetAllNamedRoles(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllNamedRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedRoles'
type MockIEnforcer_GetAllNamedRoles_Call struct {
	*mock.Call
}

// GetAllNamedRoles is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetAllNamedRoles(ptype interface{}) *MockIEnforcer_GetAllNamedRoles_Call {
	return &MockIEnforcer_GetAllNamedRoles_Call{Call: _e.mock.On("GetAllNamedRoles", ptype)}
}

func (_c *MockIEnforcer_GetAllNamedRoles_Call) Run(run func(ptype string)) *MockIEnforcer_GetAllNamedRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllNamedRoles_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllNamedRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllNamedRoles_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllNamedRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNamedSubjects provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetAllNamedSubjects(ptype string) ([]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNamedSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllNamedSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNamedSubjects'
type MockIEnforcer_GetAllNamedSubjects_Call struct {
	*mock.Call
}

// GetAllNamedSubjects is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetAllNamedSubjects(ptype interface{}) *MockIEnforcer_GetAllNamedSubjects_Call {
	return &MockIEnforcer_GetAllNamedSubjects_Call{Call: _e.mock.On("GetAllNamedSubjects", ptype)}
}

func (_c *MockIEnforcer_GetAllNamedSubjects_Call) Run(run func(ptype string)) *MockIEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllNamedSubjects_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllNamedSubjects_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllNamedSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllObjects provides a mock function with no fields
func (_m *MockIEnforcer) GetAllObjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllObjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllObjects'
type MockIEnforcer_GetAllObjects_Call struct {
	*mock.Call
}

// GetAllObjects is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAllObjects() *MockIEnforcer_GetAllObjects_Call {
	return &MockIEnforcer_GetAllObjects_Call{Call: _e.mock.On("GetAllObjects")}
}

func (_c *MockIEnforcer_GetAllObjects_Call) Run(run func()) *MockIEnforcer_GetAllObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAllObjects_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllObjects_Call) RunAndReturn(run func() ([]string, error)) *MockIEnforcer_GetAllObjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllRoles provides a mock function with no fields
func (_m *MockIEnforcer) GetAllRoles() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllRoles'
type MockIEnforcer_GetAllRoles_Call struct {
	*mock.Call
}

// GetAllRoles is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAllRoles() *MockIEnforcer_GetAllRoles_Call {
	return &MockIEnforcer_GetAllRoles_Call{Call: _e.mock.On("GetAllRoles")}
}

func (_c *MockIEnforcer_GetAllRoles_Call) Run(run func()) *MockIEnforcer_GetAllRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAllRoles_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllRoles_Call) RunAndReturn(run func() ([]string, error)) *MockIEnforcer_GetAllRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllRolesByDomain provides a mock function with given fields: domain
func (_m *MockIEnforcer) GetAllRolesByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllRolesByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllRolesByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllRolesByDomain'
type MockIEnforcer_GetAllRolesByDomain_Call struct {
	*mock.Call
}

// GetAllRolesByDomain is a helper method to define mock.On call
//   - domain string
func (_e *MockIEnforcer_Expecter) GetAllRolesByDomain(domain interface{}) *MockIEnforcer_GetAllRolesByDomain_Call {
	return &MockIEnforcer_GetAllRolesByDomain_Call{Call: _e.mock.On("GetAllRolesByDomain", domain)}
}

func (_c *MockIEnforcer_GetAllRolesByDomain_Call) Run(run func(domain string)) *MockIEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllRolesByDomain_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllRolesByDomain_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllRolesByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllSubjects provides a mock function with no fields
func (_m *MockIEnforcer) GetAllSubjects() ([]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllSubjects")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllSubjects'
type MockIEnforcer_GetAllSubjects_Call struct {
	*mock.Call
}

// GetAllSubjects is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetAllSubjects() *MockIEnforcer_GetAllSubjects_Call {
	return &MockIEnforcer_GetAllSubjects_Call{Call: _e.mock.On("GetAllSubjects")}
}

func (_c *MockIEnforcer_GetAllSubjects_Call) Run(run func()) *MockIEnforcer_GetAllSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetAllSubjects_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllSubjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllSubjects_Call) RunAndReturn(run func() ([]string, error)) *MockIEnforcer_GetAllSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUsersByDomain provides a mock function with given fields: domain
func (_m *MockIEnforcer) GetAllUsersByDomain(domain string) ([]string, error) {
	ret := _m.Called(domain)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUsersByDomain")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(domain)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetAllUsersByDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUsersByDomain'
type MockIEnforcer_GetAllUsersByDomain_Call struct {
	*mock.Call
}

// GetAllUsersByDomain is a helper method to define mock.On call
//   - domain string
func (_e *MockIEnforcer_Expecter) GetAllUsersByDomain(domain interface{}) *MockIEnforcer_GetAllUsersByDomain_Call {
	return &MockIEnforcer_GetAllUsersByDomain_Call{Call: _e.mock.On("GetAllUsersByDomain", domain)}
}

func (_c *MockIEnforcer_GetAllUsersByDomain_Call) Run(run func(domain string)) *MockIEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetAllUsersByDomain_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetAllUsersByDomain_Call) RunAndReturn(run func(string) ([]string, error)) *MockIEnforcer_GetAllUsersByDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *MockIEnforcer) GetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetFilteredGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredGroupingPolicy'
type MockIEnforcer_GetFilteredGroupingPolicy_Call struct {
	*mock.Call
}

// GetFilteredGroupingPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) GetFilteredGroupingPolicy(fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_GetFilteredGroupingPolicy_Call {
	return &MockIEnforcer_GetFilteredGroupingPolicy_Call{Call: _e.mock.On("GetFilteredGroupingPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_GetFilteredGroupingPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *MockIEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetFilteredGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetFilteredGroupingPolicy_Call) RunAndReturn(run func(int, ...string) ([][]string, error)) *MockIEnforcer_GetFilteredGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *MockIEnforcer) GetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetFilteredNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredNamedGroupingPolicy'
type MockIEnforcer_GetFilteredNamedGroupingPolicy_Call struct {
	*mock.Call
}

// GetFilteredNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) GetFilteredNamedGroupingPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call {
	return &MockIEnforcer_GetFilteredNamedGroupingPolicy_Call{Call: _e.mock.On("GetFilteredNamedGroupingPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call) RunAndReturn(run func(string, int, ...string) ([][]string, error)) *MockIEnforcer_GetFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *MockIEnforcer) GetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) ([][]string, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) [][]string); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetFilteredNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredNamedPolicy'
type MockIEnforcer_GetFilteredNamedPolicy_Call struct {
	*mock.Call
}

// GetFilteredNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) GetFilteredNamedPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_GetFilteredNamedPolicy_Call {
	return &MockIEnforcer_GetFilteredNamedPolicy_Call{Call: _e.mock.On("GetFilteredNamedPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_GetFilteredNamedPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetFilteredNamedPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetFilteredNamedPolicy_Call) RunAndReturn(run func(string, int, ...string) ([][]string, error)) *MockIEnforcer_GetFilteredNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *MockIEnforcer) GetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFilteredPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) ([][]string, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) [][]string); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilteredPolicy'
type MockIEnforcer_GetFilteredPolicy_Call struct {
	*mock.Call
}

// GetFilteredPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) GetFilteredPolicy(fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_GetFilteredPolicy_Call {
	return &MockIEnforcer_GetFilteredPolicy_Call{Call: _e.mock.On("GetFilteredPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_GetFilteredPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *MockIEnforcer_GetFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetFilteredPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetFilteredPolicy_Call) RunAndReturn(run func(int, ...string) ([][]string, error)) *MockIEnforcer_GetFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupingPolicy provides a mock function with no fields
func (_m *MockIEnforcer) GetGroupingPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupingPolicy'
type MockIEnforcer_GetGroupingPolicy_Call struct {
	*mock.Call
}

// GetGroupingPolicy is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetGroupingPolicy() *MockIEnforcer_GetGroupingPolicy_Call {
	return &MockIEnforcer_GetGroupingPolicy_Call{Call: _e.mock.On("GetGroupingPolicy")}
}

func (_c *MockIEnforcer_GetGroupingPolicy_Call) Run(run func()) *MockIEnforcer_GetGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetGroupingPolicy_Call) RunAndReturn(run func() ([][]string, error)) *MockIEnforcer_GetGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitPermissionsForUser provides a mock function with given fields: user, domain
func (_m *MockIEnforcer) GetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetImplicitPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitPermissionsForUser'
type MockIEnforcer_GetImplicitPermissionsForUser_Call struct {
	*mock.Call
}

// GetImplicitPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) GetImplicitPermissionsForUser(user interface{}, domain ...interface{}) *MockIEnforcer_GetImplicitPermissionsForUser_Call {
	return &MockIEnforcer_GetImplicitPermissionsForUser_Call{Call: _e.mock.On("GetImplicitPermissionsForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *MockIEnforcer_GetImplicitPermissionsForUser_Call) Run(run func(user string, domain ...string)) *MockIEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetImplicitPermissionsForUser_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetImplicitPermissionsForUser_Call) RunAndReturn(run func(string, ...string) ([][]string, error)) *MockIEnforcer_GetImplicitPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitRolesForUser provides a mock function with given fields: name, domain
func (_m *MockIEnforcer) GetImplicitRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetImplicitRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitRolesForUser'
type MockIEnforcer_GetImplicitRolesForUser_Call struct {
	*mock.Call
}

// GetImplicitRolesForUser is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) GetImplicitRolesForUser(name interface{}, domain ...interface{}) *MockIEnforcer_GetImplicitRolesForUser_Call {
	return &MockIEnforcer_GetImplicitRolesForUser_Call{Call: _e.mock.On("GetImplicitRolesForUser",
		append([]interface{}{name}, domain...)...)}
}

func (_c *MockIEnforcer_GetImplicitRolesForUser_Call) Run(run func(name string, domain ...string)) *MockIEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetImplicitRolesForUser_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetImplicitRolesForUser_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *MockIEnforcer_GetImplicitRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetImplicitUsersForPermission provides a mock function with given fields: permission
func (_m *MockIEnforcer) GetImplicitUsersForPermission(permission ...string) ([]string, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImplicitUsersForPermission")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) ([]string, error)); ok {
		return rf(permission...)
	}
	if rf, ok := ret.Get(0).(func(...string) []string); ok {
		r0 = rf(permission...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetImplicitUsersForPermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImplicitUsersForPermission'
type MockIEnforcer_GetImplicitUsersForPermission_Call struct {
	*mock.Call
}

// GetImplicitUsersForPermission is a helper method to define mock.On call
//   - permission ...string
func (_e *MockIEnforcer_Expecter) GetImplicitUsersForPermission(permission ...interface{}) *MockIEnforcer_GetImplicitUsersForPermission_Call {
	return &MockIEnforcer_GetImplicitUsersForPermission_Call{Call: _e.mock.On("GetImplicitUsersForPermission",
		append([]interface{}{}, permission...)...)}
}

func (_c *MockIEnforcer_GetImplicitUsersForPermission_Call) Run(run func(permission ...string)) *MockIEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetImplicitUsersForPermission_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetImplicitUsersForPermission_Call) RunAndReturn(run func(...string) ([]string, error)) *MockIEnforcer_GetImplicitUsersForPermission_Call {
	_c.Call.Return(run)
	return _c
}

// GetModel provides a mock function with no fields
func (_m *MockIEnforcer) GetModel() model.Model {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetModel")
	}

	var r0 model.Model
	if rf, ok := ret.Get(0).(func() model.Model); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.Model)
		}
	}

	return r0
}

// MockIEnforcer_GetModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetModel'
type MockIEnforcer_GetModel_Call struct {
	*mock.Call
}

// GetModel is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetModel() *MockIEnforcer_GetModel_Call {
	return &MockIEnforcer_GetModel_Call{Call: _e.mock.On("GetModel")}
}

func (_c *MockIEnforcer_GetModel_Call) Run(run func()) *MockIEnforcer_GetModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetModel_Call) Return(_a0 model.Model) *MockIEnforcer_GetModel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetModel_Call) RunAndReturn(run func() model.Model) *MockIEnforcer_GetModel_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamedGroupingPolicy provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetNamedGroupingPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedGroupingPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamedGroupingPolicy'
type MockIEnforcer_GetNamedGroupingPolicy_Call struct {
	*mock.Call
}

// GetNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetNamedGroupingPolicy(ptype interface{}) *MockIEnforcer_GetNamedGroupingPolicy_Call {
	return &MockIEnforcer_GetNamedGroupingPolicy_Call{Call: _e.mock.On("GetNamedGroupingPolicy", ptype)}
}

func (_c *MockIEnforcer_GetNamedGroupingPolicy_Call) Run(run func(ptype string)) *MockIEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetNamedGroupingPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetNamedGroupingPolicy_Call) RunAndReturn(run func(string) ([][]string, error)) *MockIEnforcer_GetNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamedPolicy provides a mock function with given fields: ptype
func (_m *MockIEnforcer) GetNamedPolicy(ptype string) ([][]string, error) {
	ret := _m.Called(ptype)

	if len(ret) == 0 {
		panic("no return value specified for GetNamedPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([][]string, error)); ok {
		return rf(ptype)
	}
	if rf, ok := ret.Get(0).(func(string) [][]string); ok {
		r0 = rf(ptype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ptype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamedPolicy'
type MockIEnforcer_GetNamedPolicy_Call struct {
	*mock.Call
}

// GetNamedPolicy is a helper method to define mock.On call
//   - ptype string
func (_e *MockIEnforcer_Expecter) GetNamedPolicy(ptype interface{}) *MockIEnforcer_GetNamedPolicy_Call {
	return &MockIEnforcer_GetNamedPolicy_Call{Call: _e.mock.On("GetNamedPolicy", ptype)}
}

func (_c *MockIEnforcer_GetNamedPolicy_Call) Run(run func(ptype string)) *MockIEnforcer_GetNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetNamedPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetNamedPolicy_Call) RunAndReturn(run func(string) ([][]string, error)) *MockIEnforcer_GetNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsForUser provides a mock function with given fields: user, domain
func (_m *MockIEnforcer) GetPermissionsForUser(user string, domain ...string) ([][]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUser")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([][]string, error)); ok {
		return rf(user, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) [][]string); ok {
		r0 = rf(user, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetPermissionsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsForUser'
type MockIEnforcer_GetPermissionsForUser_Call struct {
	*mock.Call
}

// GetPermissionsForUser is a helper method to define mock.On call
//   - user string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) GetPermissionsForUser(user interface{}, domain ...interface{}) *MockIEnforcer_GetPermissionsForUser_Call {
	return &MockIEnforcer_GetPermissionsForUser_Call{Call: _e.mock.On("GetPermissionsForUser",
		append([]interface{}{user}, domain...)...)}
}

func (_c *MockIEnforcer_GetPermissionsForUser_Call) Run(run func(user string, domain ...string)) *MockIEnforcer_GetPermissionsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetPermissionsForUser_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetPermissionsForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetPermissionsForUser_Call) RunAndReturn(run func(string, ...string) ([][]string, error)) *MockIEnforcer_GetPermissionsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsForUserInDomain provides a mock function with given fields: user, domain
func (_m *MockIEnforcer) GetPermissionsForUserInDomain(user string, domain string) [][]string {
	ret := _m.Called(user, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsForUserInDomain")
	}

	var r0 [][]string
	if rf, ok := ret.Get(0).(func(string, string) [][]string); ok {
		r0 = rf(user, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	return r0
}

// MockIEnforcer_GetPermissionsForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsForUserInDomain'
type MockIEnforcer_GetPermissionsForUserInDomain_Call struct {
	*mock.Call
}

// GetPermissionsForUserInDomain is a helper method to define mock.On call
//   - user string
//   - domain string
func (_e *MockIEnforcer_Expecter) GetPermissionsForUserInDomain(user interface{}, domain interface{}) *MockIEnforcer_GetPermissionsForUserInDomain_Call {
	return &MockIEnforcer_GetPermissionsForUserInDomain_Call{Call: _e.mock.On("GetPermissionsForUserInDomain", user, domain)}
}

func (_c *MockIEnforcer_GetPermissionsForUserInDomain_Call) Run(run func(user string, domain string)) *MockIEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetPermissionsForUserInDomain_Call) Return(_a0 [][]string) *MockIEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetPermissionsForUserInDomain_Call) RunAndReturn(run func(string, string) [][]string) *MockIEnforcer_GetPermissionsForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicy provides a mock function with no fields
func (_m *MockIEnforcer) GetPolicy() ([][]string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPolicy")
	}

	var r0 [][]string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([][]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [][]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicy'
type MockIEnforcer_GetPolicy_Call struct {
	*mock.Call
}

// GetPolicy is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetPolicy() *MockIEnforcer_GetPolicy_Call {
	return &MockIEnforcer_GetPolicy_Call{Call: _e.mock.On("GetPolicy")}
}

func (_c *MockIEnforcer_GetPolicy_Call) Run(run func()) *MockIEnforcer_GetPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetPolicy_Call) Return(_a0 [][]string, _a1 error) *MockIEnforcer_GetPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetPolicy_Call) RunAndReturn(run func() ([][]string, error)) *MockIEnforcer_GetPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleManager provides a mock function with no fields
func (_m *MockIEnforcer) GetRoleManager() rbac.RoleManager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRoleManager")
	}

	var r0 rbac.RoleManager
	if rf, ok := ret.Get(0).(func() rbac.RoleManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rbac.RoleManager)
		}
	}

	return r0
}

// MockIEnforcer_GetRoleManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleManager'
type MockIEnforcer_GetRoleManager_Call struct {
	*mock.Call
}

// GetRoleManager is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) GetRoleManager() *MockIEnforcer_GetRoleManager_Call {
	return &MockIEnforcer_GetRoleManager_Call{Call: _e.mock.On("GetRoleManager")}
}

func (_c *MockIEnforcer_GetRoleManager_Call) Run(run func()) *MockIEnforcer_GetRoleManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_GetRoleManager_Call) Return(_a0 rbac.RoleManager) *MockIEnforcer_GetRoleManager_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetRoleManager_Call) RunAndReturn(run func() rbac.RoleManager) *MockIEnforcer_GetRoleManager_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesForUser provides a mock function with given fields: name, domain
func (_m *MockIEnforcer) GetRolesForUser(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUser")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetRolesForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesForUser'
type MockIEnforcer_GetRolesForUser_Call struct {
	*mock.Call
}

// GetRolesForUser is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) GetRolesForUser(name interface{}, domain ...interface{}) *MockIEnforcer_GetRolesForUser_Call {
	return &MockIEnforcer_GetRolesForUser_Call{Call: _e.mock.On("GetRolesForUser",
		append([]interface{}{name}, domain...)...)}
}

func (_c *MockIEnforcer_GetRolesForUser_Call) Run(run func(name string, domain ...string)) *MockIEnforcer_GetRolesForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetRolesForUser_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetRolesForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetRolesForUser_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *MockIEnforcer_GetRolesForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesForUserInDomain provides a mock function with given fields: name, domain
func (_m *MockIEnforcer) GetRolesForUserInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForUserInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockIEnforcer_GetRolesForUserInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesForUserInDomain'
type MockIEnforcer_GetRolesForUserInDomain_Call struct {
	*mock.Call
}

// GetRolesForUserInDomain is a helper method to define mock.On call
//   - name string
//   - domain string
func (_e *MockIEnforcer_Expecter) GetRolesForUserInDomain(name interface{}, domain interface{}) *MockIEnforcer_GetRolesForUserInDomain_Call {
	return &MockIEnforcer_GetRolesForUserInDomain_Call{Call: _e.mock.On("GetRolesForUserInDomain", name, domain)}
}

func (_c *MockIEnforcer_GetRolesForUserInDomain_Call) Run(run func(name string, domain string)) *MockIEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetRolesForUserInDomain_Call) Return(_a0 []string) *MockIEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetRolesForUserInDomain_Call) RunAndReturn(run func(string, string) []string) *MockIEnforcer_GetRolesForUserInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersForRole provides a mock function with given fields: name, domain
func (_m *MockIEnforcer) GetUsersForRole(name string, domain ...string) ([]string, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRole")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) ([]string, error)); ok {
		return rf(name, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) []string); ok {
		r0 = rf(name, domain...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(name, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_GetUsersForRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersForRole'
type MockIEnforcer_GetUsersForRole_Call struct {
	*mock.Call
}

// GetUsersForRole is a helper method to define mock.On call
//   - name string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) GetUsersForRole(name interface{}, domain ...interface{}) *MockIEnforcer_GetUsersForRole_Call {
	return &MockIEnforcer_GetUsersForRole_Call{Call: _e.mock.On("GetUsersForRole",
		append([]interface{}{name}, domain...)...)}
}

func (_c *MockIEnforcer_GetUsersForRole_Call) Run(run func(name string, domain ...string)) *MockIEnforcer_GetUsersForRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_GetUsersForRole_Call) Return(_a0 []string, _a1 error) *MockIEnforcer_GetUsersForRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_GetUsersForRole_Call) RunAndReturn(run func(string, ...string) ([]string, error)) *MockIEnforcer_GetUsersForRole_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersForRoleInDomain provides a mock function with given fields: name, domain
func (_m *MockIEnforcer) GetUsersForRoleInDomain(name string, domain string) []string {
	ret := _m.Called(name, domain)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersForRoleInDomain")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(name, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockIEnforcer_GetUsersForRoleInDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersForRoleInDomain'
type MockIEnforcer_GetUsersForRoleInDomain_Call struct {
	*mock.Call
}

// GetUsersForRoleInDomain is a helper method to define mock.On call
//   - name string
//   - domain string
func (_e *MockIEnforcer_Expecter) GetUsersForRoleInDomain(name interface{}, domain interface{}) *MockIEnforcer_GetUsersForRoleInDomain_Call {
	return &MockIEnforcer_GetUsersForRoleInDomain_Call{Call: _e.mock.On("GetUsersForRoleInDomain", name, domain)}
}

func (_c *MockIEnforcer_GetUsersForRoleInDomain_Call) Run(run func(name string, domain string)) *MockIEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockIEnforcer_GetUsersForRoleInDomain_Call) Return(_a0 []string) *MockIEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_GetUsersForRoleInDomain_Call) RunAndReturn(run func(string, string) []string) *MockIEnforcer_GetUsersForRoleInDomain_Call {
	_c.Call.Return(run)
	return _c
}

// HasGroupingPolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) HasGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasGroupingPolicy'
type MockIEnforcer_HasGroupingPolicy_Call struct {
	*mock.Call
}

// HasGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) HasGroupingPolicy(params ...interface{}) *MockIEnforcer_HasGroupingPolicy_Call {
	return &MockIEnforcer_HasGroupingPolicy_Call{Call: _e.mock.On("HasGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_HasGroupingPolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_HasGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_HasGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) HasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasNamedGroupingPolicy'
type MockIEnforcer_HasNamedGroupingPolicy_Call struct {
	*mock.Call
}

// HasNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) HasNamedGroupingPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_HasNamedGroupingPolicy_Call {
	return &MockIEnforcer_HasNamedGroupingPolicy_Call{Call: _e.mock.On("HasNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_HasNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_HasNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasNamedPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) HasNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasNamedPolicy'
type MockIEnforcer_HasNamedPolicy_Call struct {
	*mock.Call
}

// HasNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) HasNamedPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_HasNamedPolicy_Call {
	return &MockIEnforcer_HasNamedPolicy_Call{Call: _e.mock.On("HasNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_HasNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_HasNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasNamedPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_HasNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasPermissionForUser provides a mock function with given fields: user, permission
func (_m *MockIEnforcer) HasPermissionForUser(user string, permission ...string) (bool, error) {
	_va := make([]interface{}, len(permission))
	for _i := range permission {
		_va[_i] = permission[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPermissionForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...string) (bool, error)); ok {
		return rf(user, permission...)
	}
	if rf, ok := ret.Get(0).(func(string, ...string) bool); ok {
		r0 = rf(user, permission...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...string) error); ok {
		r1 = rf(user, permission...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasPermissionForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasPermissionForUser'
type MockIEnforcer_HasPermissionForUser_Call struct {
	*mock.Call
}

// HasPermissionForUser is a helper method to define mock.On call
//   - user string
//   - permission ...string
func (_e *MockIEnforcer_Expecter) HasPermissionForUser(user interface{}, permission ...interface{}) *MockIEnforcer_HasPermissionForUser_Call {
	return &MockIEnforcer_HasPermissionForUser_Call{Call: _e.mock.On("HasPermissionForUser",
		append([]interface{}{user}, permission...)...)}
}

func (_c *MockIEnforcer_HasPermissionForUser_Call) Run(run func(user string, permission ...string)) *MockIEnforcer_HasPermissionForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasPermissionForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasPermissionForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasPermissionForUser_Call) RunAndReturn(run func(string, ...string) (bool, error)) *MockIEnforcer_HasPermissionForUser_Call {
	_c.Call.Return(run)
	return _c
}

// HasPolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) HasPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasPolicy'
type MockIEnforcer_HasPolicy_Call struct {
	*mock.Call
}

// HasPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) HasPolicy(params ...interface{}) *MockIEnforcer_HasPolicy_Call {
	return &MockIEnforcer_HasPolicy_Call{Call: _e.mock.On("HasPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_HasPolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_HasPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_HasPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// HasRoleForUser provides a mock function with given fields: name, role, domain
func (_m *MockIEnforcer) HasRoleForUser(name string, role string, domain ...string) (bool, error) {
	_va := make([]interface{}, len(domain))
	for _i := range domain {
		_va[_i] = domain[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, role)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasRoleForUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...string) (bool, error)); ok {
		return rf(name, role, domain...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...string) bool); ok {
		r0 = rf(name, role, domain...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...string) error); ok {
		r1 = rf(name, role, domain...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_HasRoleForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasRoleForUser'
type MockIEnforcer_HasRoleForUser_Call struct {
	*mock.Call
}

// HasRoleForUser is a helper method to define mock.On call
//   - name string
//   - role string
//   - domain ...string
func (_e *MockIEnforcer_Expecter) HasRoleForUser(name interface{}, role interface{}, domain ...interface{}) *MockIEnforcer_HasRoleForUser_Call {
	return &MockIEnforcer_HasRoleForUser_Call{Call: _e.mock.On("HasRoleForUser",
		append([]interface{}{name, role}, domain...)...)}
}

func (_c *MockIEnforcer_HasRoleForUser_Call) Run(run func(name string, role string, domain ...string)) *MockIEnforcer_HasRoleForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_HasRoleForUser_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_HasRoleForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_HasRoleForUser_Call) RunAndReturn(run func(string, string, ...string) (bool, error)) *MockIEnforcer_HasRoleForUser_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithAdapter provides a mock function with given fields: modelPath, adapter
func (_m *MockIEnforcer) InitWithAdapter(modelPath string, adapter persist.Adapter) error {
	ret := _m.Called(modelPath, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, persist.Adapter) error); ok {
		r0 = rf(modelPath, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_InitWithAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithAdapter'
type MockIEnforcer_InitWithAdapter_Call struct {
	*mock.Call
}

// InitWithAdapter is a helper method to define mock.On call
//   - modelPath string
//   - adapter persist.Adapter
func (_e *MockIEnforcer_Expecter) InitWithAdapter(modelPath interface{}, adapter interface{}) *MockIEnforcer_InitWithAdapter_Call {
	return &MockIEnforcer_InitWithAdapter_Call{Call: _e.mock.On("InitWithAdapter", modelPath, adapter)}
}

func (_c *MockIEnforcer_InitWithAdapter_Call) Run(run func(modelPath string, adapter persist.Adapter)) *MockIEnforcer_InitWithAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(persist.Adapter))
	})
	return _c
}

func (_c *MockIEnforcer_InitWithAdapter_Call) Return(_a0 error) *MockIEnforcer_InitWithAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_InitWithAdapter_Call) RunAndReturn(run func(string, persist.Adapter) error) *MockIEnforcer_InitWithAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithFile provides a mock function with given fields: modelPath, policyPath
func (_m *MockIEnforcer) InitWithFile(modelPath string, policyPath string) error {
	ret := _m.Called(modelPath, policyPath)

	if len(ret) == 0 {
		panic("no return value specified for InitWithFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(modelPath, policyPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_InitWithFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithFile'
type MockIEnforcer_InitWithFile_Call struct {
	*mock.Call
}

// InitWithFile is a helper method to define mock.On call
//   - modelPath string
//   - policyPath string
func (_e *MockIEnforcer_Expecter) InitWithFile(modelPath interface{}, policyPath interface{}) *MockIEnforcer_InitWithFile_Call {
	return &MockIEnforcer_InitWithFile_Call{Call: _e.mock.On("InitWithFile", modelPath, policyPath)}
}

func (_c *MockIEnforcer_InitWithFile_Call) Run(run func(modelPath string, policyPath string)) *MockIEnforcer_InitWithFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockIEnforcer_InitWithFile_Call) Return(_a0 error) *MockIEnforcer_InitWithFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_InitWithFile_Call) RunAndReturn(run func(string, string) error) *MockIEnforcer_InitWithFile_Call {
	_c.Call.Return(run)
	return _c
}

// InitWithModelAndAdapter provides a mock function with given fields: m, adapter
func (_m *MockIEnforcer) InitWithModelAndAdapter(m model.Model, adapter persist.Adapter) error {
	ret := _m.Called(m, adapter)

	if len(ret) == 0 {
		panic("no return value specified for InitWithModelAndAdapter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Model, persist.Adapter) error); ok {
		r0 = rf(m, adapter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_InitWithModelAndAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitWithModelAndAdapter'
type MockIEnforcer_InitWithModelAndAdapter_Call struct {
	*mock.Call
}

// InitWithModelAndAdapter is a helper method to define mock.On call
//   - m model.Model
//   - adapter persist.Adapter
func (_e *MockIEnforcer_Expecter) InitWithModelAndAdapter(m interface{}, adapter interface{}) *MockIEnforcer_InitWithModelAndAdapter_Call {
	return &MockIEnforcer_InitWithModelAndAdapter_Call{Call: _e.mock.On("InitWithModelAndAdapter", m, adapter)}
}

func (_c *MockIEnforcer_InitWithModelAndAdapter_Call) Run(run func(m model.Model, adapter persist.Adapter)) *MockIEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Model), args[1].(persist.Adapter))
	})
	return _c
}

func (_c *MockIEnforcer_InitWithModelAndAdapter_Call) Return(_a0 error) *MockIEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_InitWithModelAndAdapter_Call) RunAndReturn(run func(model.Model, persist.Adapter) error) *MockIEnforcer_InitWithModelAndAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// IsFiltered provides a mock function with no fields
func (_m *MockIEnforcer) IsFiltered() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsFiltered")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockIEnforcer_IsFiltered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsFiltered'
type MockIEnforcer_IsFiltered_Call struct {
	*mock.Call
}

// IsFiltered is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) IsFiltered() *MockIEnforcer_IsFiltered_Call {
	return &MockIEnforcer_IsFiltered_Call{Call: _e.mock.On("IsFiltered")}
}

func (_c *MockIEnforcer_IsFiltered_Call) Run(run func()) *MockIEnforcer_IsFiltered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_IsFiltered_Call) Return(_a0 bool) *MockIEnforcer_IsFiltered_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_IsFiltered_Call) RunAndReturn(run func() bool) *MockIEnforcer_IsFiltered_Call {
	_c.Call.Return(run)
	return _c
}

// LoadFilteredPolicy provides a mock function with given fields: filter
func (_m *MockIEnforcer) LoadFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_LoadFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadFilteredPolicy'
type MockIEnforcer_LoadFilteredPolicy_Call struct {
	*mock.Call
}

// LoadFilteredPolicy is a helper method to define mock.On call
//   - filter interface{}
func (_e *MockIEnforcer_Expecter) LoadFilteredPolicy(filter interface{}) *MockIEnforcer_LoadFilteredPolicy_Call {
	return &MockIEnforcer_LoadFilteredPolicy_Call{Call: _e.mock.On("LoadFilteredPolicy", filter)}
}

func (_c *MockIEnforcer_LoadFilteredPolicy_Call) Run(run func(filter interface{})) *MockIEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockIEnforcer_LoadFilteredPolicy_Call) Return(_a0 error) *MockIEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_LoadFilteredPolicy_Call) RunAndReturn(run func(interface{}) error) *MockIEnforcer_LoadFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// LoadIncrementalFilteredPolicy provides a mock function with given fields: filter
func (_m *MockIEnforcer) LoadIncrementalFilteredPolicy(filter interface{}) error {
	ret := _m.Called(filter)

	if len(ret) == 0 {
		panic("no return value specified for LoadIncrementalFilteredPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_LoadIncrementalFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadIncrementalFilteredPolicy'
type MockIEnforcer_LoadIncrementalFilteredPolicy_Call struct {
	*mock.Call
}

// LoadIncrementalFilteredPolicy is a helper method to define mock.On call
//   - filter interface{}
func (_e *MockIEnforcer_Expecter) LoadIncrementalFilteredPolicy(filter interface{}) *MockIEnforcer_LoadIncrementalFilteredPolicy_Call {
	return &MockIEnforcer_LoadIncrementalFilteredPolicy_Call{Call: _e.mock.On("LoadIncrementalFilteredPolicy", filter)}
}

func (_c *MockIEnforcer_LoadIncrementalFilteredPolicy_Call) Run(run func(filter interface{})) *MockIEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockIEnforcer_LoadIncrementalFilteredPolicy_Call) Return(_a0 error) *MockIEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_LoadIncrementalFilteredPolicy_Call) RunAndReturn(run func(interface{}) error) *MockIEnforcer_LoadIncrementalFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// LoadModel provides a mock function with no fields
func (_m *MockIEnforcer) LoadModel() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadModel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_LoadModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadModel'
type MockIEnforcer_LoadModel_Call struct {
	*mock.Call
}

// LoadModel is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) LoadModel() *MockIEnforcer_LoadModel_Call {
	return &MockIEnforcer_LoadModel_Call{Call: _e.mock.On("LoadModel")}
}

func (_c *MockIEnforcer_LoadModel_Call) Run(run func()) *MockIEnforcer_LoadModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_LoadModel_Call) Return(_a0 error) *MockIEnforcer_LoadModel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_LoadModel_Call) RunAndReturn(run func() error) *MockIEnforcer_LoadModel_Call {
	_c.Call.Return(run)
	return _c
}

// LoadPolicy provides a mock function with no fields
func (_m *MockIEnforcer) LoadPolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LoadPolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_LoadPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadPolicy'
type MockIEnforcer_LoadPolicy_Call struct {
	*mock.Call
}

// LoadPolicy is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) LoadPolicy() *MockIEnforcer_LoadPolicy_Call {
	return &MockIEnforcer_LoadPolicy_Call{Call: _e.mock.On("LoadPolicy")}
}

func (_c *MockIEnforcer_LoadPolicy_Call) Run(run func()) *MockIEnforcer_LoadPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_LoadPolicy_Call) Return(_a0 error) *MockIEnforcer_LoadPolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_LoadPolicy_Call) RunAndReturn(run func() error) *MockIEnforcer_LoadPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredGroupingPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *MockIEnforcer) RemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveFilteredGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredGroupingPolicy'
type MockIEnforcer_RemoveFilteredGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredGroupingPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) RemoveFilteredGroupingPolicy(fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_RemoveFilteredGroupingPolicy_Call {
	return &MockIEnforcer_RemoveFilteredGroupingPolicy_Call{Call: _e.mock.On("RemoveFilteredGroupingPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_RemoveFilteredGroupingPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *MockIEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredGroupingPolicy_Call) RunAndReturn(run func(int, ...string) (bool, error)) *MockIEnforcer_RemoveFilteredGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredNamedGroupingPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *MockIEnforcer) RemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredNamedGroupingPolicy'
type MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) RemoveFilteredNamedGroupingPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	return &MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call{Call: _e.mock.On("RemoveFilteredNamedGroupingPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call) RunAndReturn(run func(string, int, ...string) (bool, error)) *MockIEnforcer_RemoveFilteredNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredNamedPolicy provides a mock function with given fields: ptype, fieldIndex, fieldValues
func (_m *MockIEnforcer) RemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, ...string) (bool, error)); ok {
		return rf(ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, int, ...string) bool); ok {
		r0 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, int, ...string) error); ok {
		r1 = rf(ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveFilteredNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredNamedPolicy'
type MockIEnforcer_RemoveFilteredNamedPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) RemoveFilteredNamedPolicy(ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_RemoveFilteredNamedPolicy_Call {
	return &MockIEnforcer_RemoveFilteredNamedPolicy_Call{Call: _e.mock.On("RemoveFilteredNamedPolicy",
		append([]interface{}{ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_RemoveFilteredNamedPolicy_Call) Run(run func(ptype string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredNamedPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredNamedPolicy_Call) RunAndReturn(run func(string, int, ...string) (bool, error)) *MockIEnforcer_RemoveFilteredNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFilteredPolicy provides a mock function with given fields: fieldIndex, fieldValues
func (_m *MockIEnforcer) RemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...string) (bool, error)); ok {
		return rf(fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(int, ...string) bool); ok {
		r0 = rf(fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, ...string) error); ok {
		r1 = rf(fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFilteredPolicy'
type MockIEnforcer_RemoveFilteredPolicy_Call struct {
	*mock.Call
}

// RemoveFilteredPolicy is a helper method to define mock.On call
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) RemoveFilteredPolicy(fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_RemoveFilteredPolicy_Call {
	return &MockIEnforcer_RemoveFilteredPolicy_Call{Call: _e.mock.On("RemoveFilteredPolicy",
		append([]interface{}{fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_RemoveFilteredPolicy_Call) Run(run func(fieldIndex int, fieldValues ...string)) *MockIEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveFilteredPolicy_Call) RunAndReturn(run func(int, ...string) (bool, error)) *MockIEnforcer_RemoveFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveGroupingPolicies provides a mock function with given fields: rules
func (_m *MockIEnforcer) RemoveGroupingPolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveGroupingPolicies'
type MockIEnforcer_RemoveGroupingPolicies_Call struct {
	*mock.Call
}

// RemoveGroupingPolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) RemoveGroupingPolicies(rules interface{}) *MockIEnforcer_RemoveGroupingPolicies_Call {
	return &MockIEnforcer_RemoveGroupingPolicies_Call{Call: _e.mock.On("RemoveGroupingPolicies", rules)}
}

func (_c *MockIEnforcer_RemoveGroupingPolicies_Call) Run(run func(rules [][]string)) *MockIEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_RemoveGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveGroupingPolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_RemoveGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveGroupingPolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) RemoveGroupingPolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveGroupingPolicy'
type MockIEnforcer_RemoveGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveGroupingPolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) RemoveGroupingPolicy(params ...interface{}) *MockIEnforcer_RemoveGroupingPolicy_Call {
	return &MockIEnforcer_RemoveGroupingPolicy_Call{Call: _e.mock.On("RemoveGroupingPolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_RemoveGroupingPolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveGroupingPolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_RemoveGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedGroupingPolicies provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) RemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedGroupingPolicies'
type MockIEnforcer_RemoveNamedGroupingPolicies_Call struct {
	*mock.Call
}

// RemoveNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) RemoveNamedGroupingPolicies(ptype interface{}, rules interface{}) *MockIEnforcer_RemoveNamedGroupingPolicies_Call {
	return &MockIEnforcer_RemoveNamedGroupingPolicies_Call{Call: _e.mock.On("RemoveNamedGroupingPolicies", ptype, rules)}
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicies_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_RemoveNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedGroupingPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) RemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedGroupingPolicy'
type MockIEnforcer_RemoveNamedGroupingPolicy_Call struct {
	*mock.Call
}

// RemoveNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) RemoveNamedGroupingPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_RemoveNamedGroupingPolicy_Call {
	return &MockIEnforcer_RemoveNamedGroupingPolicy_Call{Call: _e.mock.On("RemoveNamedGroupingPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveNamedGroupingPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_RemoveNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedPolicies provides a mock function with given fields: ptype, rules
func (_m *MockIEnforcer) RemoveNamedPolicies(ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string) (bool, error)); ok {
		return rf(ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string) bool); ok {
		r0 = rf(ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string) error); ok {
		r1 = rf(ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveNamedPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedPolicies'
type MockIEnforcer_RemoveNamedPolicies_Call struct {
	*mock.Call
}

// RemoveNamedPolicies is a helper method to define mock.On call
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) RemoveNamedPolicies(ptype interface{}, rules interface{}) *MockIEnforcer_RemoveNamedPolicies_Call {
	return &MockIEnforcer_RemoveNamedPolicies_Call{Call: _e.mock.On("RemoveNamedPolicies", ptype, rules)}
}

func (_c *MockIEnforcer_RemoveNamedPolicies_Call) Run(run func(ptype string, rules [][]string)) *MockIEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_RemoveNamedPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveNamedPolicies_Call) RunAndReturn(run func(string, [][]string) (bool, error)) *MockIEnforcer_RemoveNamedPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNamedPolicy provides a mock function with given fields: ptype, params
func (_m *MockIEnforcer) RemoveNamedPolicy(ptype string, params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, ptype)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNamedPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (bool, error)); ok {
		return rf(ptype, params...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) bool); ok {
		r0 = rf(ptype, params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(ptype, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemoveNamedPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNamedPolicy'
type MockIEnforcer_RemoveNamedPolicy_Call struct {
	*mock.Call
}

// RemoveNamedPolicy is a helper method to define mock.On call
//   - ptype string
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) RemoveNamedPolicy(ptype interface{}, params ...interface{}) *MockIEnforcer_RemoveNamedPolicy_Call {
	return &MockIEnforcer_RemoveNamedPolicy_Call{Call: _e.mock.On("RemoveNamedPolicy",
		append([]interface{}{ptype}, params...)...)}
}

func (_c *MockIEnforcer_RemoveNamedPolicy_Call) Run(run func(ptype string, params ...interface{})) *MockIEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemoveNamedPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemoveNamedPolicy_Call) RunAndReturn(run func(string, ...interface{}) (bool, error)) *MockIEnforcer_RemoveNamedPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePolicies provides a mock function with given fields: rules
func (_m *MockIEnforcer) RemovePolicies(rules [][]string) (bool, error) {
	ret := _m.Called(rules)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string) (bool, error)); ok {
		return rf(rules)
	}
	if rf, ok := ret.Get(0).(func([][]string) bool); ok {
		r0 = rf(rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string) error); ok {
		r1 = rf(rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemovePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePolicies'
type MockIEnforcer_RemovePolicies_Call struct {
	*mock.Call
}

// RemovePolicies is a helper method to define mock.On call
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) RemovePolicies(rules interface{}) *MockIEnforcer_RemovePolicies_Call {
	return &MockIEnforcer_RemovePolicies_Call{Call: _e.mock.On("RemovePolicies", rules)}
}

func (_c *MockIEnforcer_RemovePolicies_Call) Run(run func(rules [][]string)) *MockIEnforcer_RemovePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_RemovePolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemovePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemovePolicies_Call) RunAndReturn(run func([][]string) (bool, error)) *MockIEnforcer_RemovePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePolicy provides a mock function with given fields: params
func (_m *MockIEnforcer) RemovePolicy(params ...interface{}) (bool, error) {
	var _ca []interface{}
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (bool, error)); ok {
		return rf(params...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) bool); ok {
		r0 = rf(params...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_RemovePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePolicy'
type MockIEnforcer_RemovePolicy_Call struct {
	*mock.Call
}

// RemovePolicy is a helper method to define mock.On call
//   - params ...interface{}
func (_e *MockIEnforcer_Expecter) RemovePolicy(params ...interface{}) *MockIEnforcer_RemovePolicy_Call {
	return &MockIEnforcer_RemovePolicy_Call{Call: _e.mock.On("RemovePolicy",
		append([]interface{}{}, params...)...)}
}

func (_c *MockIEnforcer_RemovePolicy_Call) Run(run func(params ...interface{})) *MockIEnforcer_RemovePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_RemovePolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_RemovePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_RemovePolicy_Call) RunAndReturn(run func(...interface{}) (bool, error)) *MockIEnforcer_RemovePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SavePolicy provides a mock function with no fields
func (_m *MockIEnforcer) SavePolicy() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SavePolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_SavePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SavePolicy'
type MockIEnforcer_SavePolicy_Call struct {
	*mock.Call
}

// SavePolicy is a helper method to define mock.On call
func (_e *MockIEnforcer_Expecter) SavePolicy() *MockIEnforcer_SavePolicy_Call {
	return &MockIEnforcer_SavePolicy_Call{Call: _e.mock.On("SavePolicy")}
}

func (_c *MockIEnforcer_SavePolicy_Call) Run(run func()) *MockIEnforcer_SavePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIEnforcer_SavePolicy_Call) Return(_a0 error) *MockIEnforcer_SavePolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_SavePolicy_Call) RunAndReturn(run func() error) *MockIEnforcer_SavePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPolicies provides a mock function with given fields: sec, ptype, rules
func (_m *MockIEnforcer) SelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfAddPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPolicies'
type MockIEnforcer_SelfAddPolicies_Call struct {
	*mock.Call
}

// SelfAddPolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) SelfAddPolicies(sec interface{}, ptype interface{}, rules interface{}) *MockIEnforcer_SelfAddPolicies_Call {
	return &MockIEnforcer_SelfAddPolicies_Call{Call: _e.mock.On("SelfAddPolicies", sec, ptype, rules)}
}

func (_c *MockIEnforcer_SelfAddPolicies_Call) Run(run func(sec string, ptype string, rules [][]string)) *MockIEnforcer_SelfAddPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfAddPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfAddPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfAddPolicies_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *MockIEnforcer_SelfAddPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPoliciesEx provides a mock function with given fields: sec, ptype, rules
func (_m *MockIEnforcer) SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPoliciesEx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfAddPoliciesEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPoliciesEx'
type MockIEnforcer_SelfAddPoliciesEx_Call struct {
	*mock.Call
}

// SelfAddPoliciesEx is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) SelfAddPoliciesEx(sec interface{}, ptype interface{}, rules interface{}) *MockIEnforcer_SelfAddPoliciesEx_Call {
	return &MockIEnforcer_SelfAddPoliciesEx_Call{Call: _e.mock.On("SelfAddPoliciesEx", sec, ptype, rules)}
}

func (_c *MockIEnforcer_SelfAddPoliciesEx_Call) Run(run func(sec string, ptype string, rules [][]string)) *MockIEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfAddPoliciesEx_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfAddPoliciesEx_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *MockIEnforcer_SelfAddPoliciesEx_Call {
	_c.Call.Return(run)
	return _c
}

// SelfAddPolicy provides a mock function with given fields: sec, ptype, rule
func (_m *MockIEnforcer) SelfAddPolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfAddPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfAddPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfAddPolicy'
type MockIEnforcer_SelfAddPolicy_Call struct {
	*mock.Call
}

// SelfAddPolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rule []string
func (_e *MockIEnforcer_Expecter) SelfAddPolicy(sec interface{}, ptype interface{}, rule interface{}) *MockIEnforcer_SelfAddPolicy_Call {
	return &MockIEnforcer_SelfAddPolicy_Call{Call: _e.mock.On("SelfAddPolicy", sec, ptype, rule)}
}

func (_c *MockIEnforcer_SelfAddPolicy_Call) Run(run func(sec string, ptype string, rule []string)) *MockIEnforcer_SelfAddPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfAddPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfAddPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfAddPolicy_Call) RunAndReturn(run func(string, string, []string) (bool, error)) *MockIEnforcer_SelfAddPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemoveFilteredPolicy provides a mock function with given fields: sec, ptype, fieldIndex, fieldValues
func (_m *MockIEnforcer) SelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, sec, ptype, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemoveFilteredPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) (bool, error)); ok {
		return rf(sec, ptype, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, ...string) bool); ok {
		r0 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, int, ...string) error); ok {
		r1 = rf(sec, ptype, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfRemoveFilteredPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemoveFilteredPolicy'
type MockIEnforcer_SelfRemoveFilteredPolicy_Call struct {
	*mock.Call
}

// SelfRemoveFilteredPolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) SelfRemoveFilteredPolicy(sec interface{}, ptype interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_SelfRemoveFilteredPolicy_Call {
	return &MockIEnforcer_SelfRemoveFilteredPolicy_Call{Call: _e.mock.On("SelfRemoveFilteredPolicy",
		append([]interface{}{sec, ptype, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_SelfRemoveFilteredPolicy_Call) Run(run func(sec string, ptype string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_SelfRemoveFilteredPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfRemoveFilteredPolicy_Call) RunAndReturn(run func(string, string, int, ...string) (bool, error)) *MockIEnforcer_SelfRemoveFilteredPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemovePolicies provides a mock function with given fields: sec, ptype, rules
func (_m *MockIEnforcer) SelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, rules)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, rules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string) bool); ok {
		r0 = rf(sec, ptype, rules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string) error); ok {
		r1 = rf(sec, ptype, rules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfRemovePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemovePolicies'
type MockIEnforcer_SelfRemovePolicies_Call struct {
	*mock.Call
}

// SelfRemovePolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rules [][]string
func (_e *MockIEnforcer_Expecter) SelfRemovePolicies(sec interface{}, ptype interface{}, rules interface{}) *MockIEnforcer_SelfRemovePolicies_Call {
	return &MockIEnforcer_SelfRemovePolicies_Call{Call: _e.mock.On("SelfRemovePolicies", sec, ptype, rules)}
}

func (_c *MockIEnforcer_SelfRemovePolicies_Call) Run(run func(sec string, ptype string, rules [][]string)) *MockIEnforcer_SelfRemovePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfRemovePolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfRemovePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfRemovePolicies_Call) RunAndReturn(run func(string, string, [][]string) (bool, error)) *MockIEnforcer_SelfRemovePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfRemovePolicy provides a mock function with given fields: sec, ptype, rule
func (_m *MockIEnforcer) SelfRemovePolicy(sec string, ptype string, rule []string) (bool, error) {
	ret := _m.Called(sec, ptype, rule)

	if len(ret) == 0 {
		panic("no return value specified for SelfRemovePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string) (bool, error)); ok {
		return rf(sec, ptype, rule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string) bool); ok {
		r0 = rf(sec, ptype, rule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string) error); ok {
		r1 = rf(sec, ptype, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfRemovePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfRemovePolicy'
type MockIEnforcer_SelfRemovePolicy_Call struct {
	*mock.Call
}

// SelfRemovePolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - rule []string
func (_e *MockIEnforcer_Expecter) SelfRemovePolicy(sec interface{}, ptype interface{}, rule interface{}) *MockIEnforcer_SelfRemovePolicy_Call {
	return &MockIEnforcer_SelfRemovePolicy_Call{Call: _e.mock.On("SelfRemovePolicy", sec, ptype, rule)}
}

func (_c *MockIEnforcer_SelfRemovePolicy_Call) Run(run func(sec string, ptype string, rule []string)) *MockIEnforcer_SelfRemovePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfRemovePolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfRemovePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfRemovePolicy_Call) RunAndReturn(run func(string, string, []string) (bool, error)) *MockIEnforcer_SelfRemovePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SelfUpdatePolicies provides a mock function with given fields: sec, ptype, oldRules, newRules
func (_m *MockIEnforcer) SelfUpdatePolicies(sec string, ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) (bool, error)); ok {
		return rf(sec, ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, string, [][]string, [][]string) bool); ok {
		r0 = rf(sec, ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, [][]string, [][]string) error); ok {
		r1 = rf(sec, ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfUpdatePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfUpdatePolicies'
type MockIEnforcer_SelfUpdatePolicies_Call struct {
	*mock.Call
}

// SelfUpdatePolicies is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - oldRules [][]string
//   - newRules [][]string
func (_e *MockIEnforcer_Expecter) SelfUpdatePolicies(sec interface{}, ptype interface{}, oldRules interface{}, newRules interface{}) *MockIEnforcer_SelfUpdatePolicies_Call {
	return &MockIEnforcer_SelfUpdatePolicies_Call{Call: _e.mock.On("SelfUpdatePolicies", sec, ptype, oldRules, newRules)}
}

func (_c *MockIEnforcer_SelfUpdatePolicies_Call) Run(run func(sec string, ptype string, oldRules [][]string, newRules [][]string)) *MockIEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([][]string), args[3].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfUpdatePolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfUpdatePolicies_Call) RunAndReturn(run func(string, string, [][]string, [][]string) (bool, error)) *MockIEnforcer_SelfUpdatePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// SelfUpdatePolicy provides a mock function with given fields: sec, ptype, oldRule, newRule
func (_m *MockIEnforcer) SelfUpdatePolicy(sec string, ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(sec, ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for SelfUpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) (bool, error)); ok {
		return rf(sec, ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, string, []string, []string) bool); ok {
		r0 = rf(sec, ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, []string, []string) error); ok {
		r1 = rf(sec, ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_SelfUpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelfUpdatePolicy'
type MockIEnforcer_SelfUpdatePolicy_Call struct {
	*mock.Call
}

// SelfUpdatePolicy is a helper method to define mock.On call
//   - sec string
//   - ptype string
//   - oldRule []string
//   - newRule []string
func (_e *MockIEnforcer_Expecter) SelfUpdatePolicy(sec interface{}, ptype interface{}, oldRule interface{}, newRule interface{}) *MockIEnforcer_SelfUpdatePolicy_Call {
	return &MockIEnforcer_SelfUpdatePolicy_Call{Call: _e.mock.On("SelfUpdatePolicy", sec, ptype, oldRule, newRule)}
}

func (_c *MockIEnforcer_SelfUpdatePolicy_Call) Run(run func(sec string, ptype string, oldRule []string, newRule []string)) *MockIEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string), args[3].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_SelfUpdatePolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_SelfUpdatePolicy_Call) RunAndReturn(run func(string, string, []string, []string) (bool, error)) *MockIEnforcer_SelfUpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// SetAdapter provides a mock function with given fields: adapter
func (_m *MockIEnforcer) SetAdapter(adapter persist.Adapter) {
	_m.Called(adapter)
}

// MockIEnforcer_SetAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAdapter'
type MockIEnforcer_SetAdapter_Call struct {
	*mock.Call
}

// SetAdapter is a helper method to define mock.On call
//   - adapter persist.Adapter
func (_e *MockIEnforcer_Expecter) SetAdapter(adapter interface{}) *MockIEnforcer_SetAdapter_Call {
	return &MockIEnforcer_SetAdapter_Call{Call: _e.mock.On("SetAdapter", adapter)}
}

func (_c *MockIEnforcer_SetAdapter_Call) Run(run func(adapter persist.Adapter)) *MockIEnforcer_SetAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(persist.Adapter))
	})
	return _c
}

func (_c *MockIEnforcer_SetAdapter_Call) Return() *MockIEnforcer_SetAdapter_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_SetAdapter_Call) RunAndReturn(run func(persist.Adapter)) *MockIEnforcer_SetAdapter_Call {
	_c.Run(run)
	return _c
}

// SetEffector provides a mock function with given fields: eft
func (_m *MockIEnforcer) SetEffector(eft effector.Effector) {
	_m.Called(eft)
}

// MockIEnforcer_SetEffector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEffector'
type MockIEnforcer_SetEffector_Call struct {
	*mock.Call
}

// SetEffector is a helper method to define mock.On call
//   - eft effector.Effector
func (_e *MockIEnforcer_Expecter) SetEffector(eft interface{}) *MockIEnforcer_SetEffector_Call {
	return &MockIEnforcer_SetEffector_Call{Call: _e.mock.On("SetEffector", eft)}
}

func (_c *MockIEnforcer_SetEffector_Call) Run(run func(eft effector.Effector)) *MockIEnforcer_SetEffector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(effector.Effector))
	})
	return _c
}

func (_c *MockIEnforcer_SetEffector_Call) Return() *MockIEnforcer_SetEffector_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_SetEffector_Call) RunAndReturn(run func(effector.Effector)) *MockIEnforcer_SetEffector_Call {
	_c.Run(run)
	return _c
}

// SetModel provides a mock function with given fields: m
func (_m *MockIEnforcer) SetModel(m model.Model) {
	_m.Called(m)
}

// MockIEnforcer_SetModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetModel'
type MockIEnforcer_SetModel_Call struct {
	*mock.Call
}

// SetModel is a helper method to define mock.On call
//   - m model.Model
func (_e *MockIEnforcer_Expecter) SetModel(m interface{}) *MockIEnforcer_SetModel_Call {
	return &MockIEnforcer_SetModel_Call{Call: _e.mock.On("SetModel", m)}
}

func (_c *MockIEnforcer_SetModel_Call) Run(run func(m model.Model)) *MockIEnforcer_SetModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Model))
	})
	return _c
}

func (_c *MockIEnforcer_SetModel_Call) Return() *MockIEnforcer_SetModel_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_SetModel_Call) RunAndReturn(run func(model.Model)) *MockIEnforcer_SetModel_Call {
	_c.Run(run)
	return _c
}

// SetRoleManager provides a mock function with given fields: rm
func (_m *MockIEnforcer) SetRoleManager(rm rbac.RoleManager) {
	_m.Called(rm)
}

// MockIEnforcer_SetRoleManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoleManager'
type MockIEnforcer_SetRoleManager_Call struct {
	*mock.Call
}

// SetRoleManager is a helper method to define mock.On call
//   - rm rbac.RoleManager
func (_e *MockIEnforcer_Expecter) SetRoleManager(rm interface{}) *MockIEnforcer_SetRoleManager_Call {
	return &MockIEnforcer_SetRoleManager_Call{Call: _e.mock.On("SetRoleManager", rm)}
}

func (_c *MockIEnforcer_SetRoleManager_Call) Run(run func(rm rbac.RoleManager)) *MockIEnforcer_SetRoleManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(rbac.RoleManager))
	})
	return _c
}

func (_c *MockIEnforcer_SetRoleManager_Call) Return() *MockIEnforcer_SetRoleManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockIEnforcer_SetRoleManager_Call) RunAndReturn(run func(rbac.RoleManager)) *MockIEnforcer_SetRoleManager_Call {
	_c.Run(run)
	return _c
}

// SetWatcher provides a mock function with given fields: watcher
func (_m *MockIEnforcer) SetWatcher(watcher persist.Watcher) error {
	ret := _m.Called(watcher)

	if len(ret) == 0 {
		panic("no return value specified for SetWatcher")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(persist.Watcher) error); ok {
		r0 = rf(watcher)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIEnforcer_SetWatcher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWatcher'
type MockIEnforcer_SetWatcher_Call struct {
	*mock.Call
}

// SetWatcher is a helper method to define mock.On call
//   - watcher persist.Watcher
func (_e *MockIEnforcer_Expecter) SetWatcher(watcher interface{}) *MockIEnforcer_SetWatcher_Call {
	return &MockIEnforcer_SetWatcher_Call{Call: _e.mock.On("SetWatcher", watcher)}
}

func (_c *MockIEnforcer_SetWatcher_Call) Run(run func(watcher persist.Watcher)) *MockIEnforcer_SetWatcher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(persist.Watcher))
	})
	return _c
}

func (_c *MockIEnforcer_SetWatcher_Call) Return(_a0 error) *MockIEnforcer_SetWatcher_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIEnforcer_SetWatcher_Call) RunAndReturn(run func(persist.Watcher) error) *MockIEnforcer_SetWatcher_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateFilteredPolicies provides a mock function with given fields: newPolicies, fieldIndex, fieldValues
func (_m *MockIEnforcer) UpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {
	_va := make([]interface{}, len(fieldValues))
	for _i := range fieldValues {
		_va[_i] = fieldValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, newPolicies, fieldIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFilteredPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) (bool, error)); ok {
		return rf(newPolicies, fieldIndex, fieldValues...)
	}
	if rf, ok := ret.Get(0).(func([][]string, int, ...string) bool); ok {
		r0 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, int, ...string) error); ok {
		r1 = rf(newPolicies, fieldIndex, fieldValues...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdateFilteredPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateFilteredPolicies'
type MockIEnforcer_UpdateFilteredPolicies_Call struct {
	*mock.Call
}

// UpdateFilteredPolicies is a helper method to define mock.On call
//   - newPolicies [][]string
//   - fieldIndex int
//   - fieldValues ...string
func (_e *MockIEnforcer_Expecter) UpdateFilteredPolicies(newPolicies interface{}, fieldIndex interface{}, fieldValues ...interface{}) *MockIEnforcer_UpdateFilteredPolicies_Call {
	return &MockIEnforcer_UpdateFilteredPolicies_Call{Call: _e.mock.On("UpdateFilteredPolicies",
		append([]interface{}{newPolicies, fieldIndex}, fieldValues...)...)}
}

func (_c *MockIEnforcer_UpdateFilteredPolicies_Call) Run(run func(newPolicies [][]string, fieldIndex int, fieldValues ...string)) *MockIEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].([][]string), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockIEnforcer_UpdateFilteredPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdateFilteredPolicies_Call) RunAndReturn(run func([][]string, int, ...string) (bool, error)) *MockIEnforcer_UpdateFilteredPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroupingPolicies provides a mock function with given fields: oldRules, newRules
func (_m *MockIEnforcer) UpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdateGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroupingPolicies'
type MockIEnforcer_UpdateGroupingPolicies_Call struct {
	*mock.Call
}

// UpdateGroupingPolicies is a helper method to define mock.On call
//   - oldRules [][]string
//   - newRules [][]string
func (_e *MockIEnforcer_Expecter) UpdateGroupingPolicies(oldRules interface{}, newRules interface{}) *MockIEnforcer_UpdateGroupingPolicies_Call {
	return &MockIEnforcer_UpdateGroupingPolicies_Call{Call: _e.mock.On("UpdateGroupingPolicies", oldRules, newRules)}
}

func (_c *MockIEnforcer_UpdateGroupingPolicies_Call) Run(run func(oldRules [][]string, newRules [][]string)) *MockIEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdateGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdateGroupingPolicies_Call) RunAndReturn(run func([][]string, [][]string) (bool, error)) *MockIEnforcer_UpdateGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroupingPolicy provides a mock function with given fields: oldRule, newRule
func (_m *MockIEnforcer) UpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdateGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroupingPolicy'
type MockIEnforcer_UpdateGroupingPolicy_Call struct {
	*mock.Call
}

// UpdateGroupingPolicy is a helper method to define mock.On call
//   - oldRule []string
//   - newRule []string
func (_e *MockIEnforcer_Expecter) UpdateGroupingPolicy(oldRule interface{}, newRule interface{}) *MockIEnforcer_UpdateGroupingPolicy_Call {
	return &MockIEnforcer_UpdateGroupingPolicy_Call{Call: _e.mock.On("UpdateGroupingPolicy", oldRule, newRule)}
}

func (_c *MockIEnforcer_UpdateGroupingPolicy_Call) Run(run func(oldRule []string, newRule []string)) *MockIEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdateGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdateGroupingPolicy_Call) RunAndReturn(run func([]string, []string) (bool, error)) *MockIEnforcer_UpdateGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNamedGroupingPolicies provides a mock function with given fields: ptype, oldRules, newRules
func (_m *MockIEnforcer) UpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error) {
	ret := _m.Called(ptype, oldRules, newRules)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) (bool, error)); ok {
		return rf(ptype, oldRules, newRules)
	}
	if rf, ok := ret.Get(0).(func(string, [][]string, [][]string) bool); ok {
		r0 = rf(ptype, oldRules, newRules)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, [][]string, [][]string) error); ok {
		r1 = rf(ptype, oldRules, newRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdateNamedGroupingPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNamedGroupingPolicies'
type MockIEnforcer_UpdateNamedGroupingPolicies_Call struct {
	*mock.Call
}

// UpdateNamedGroupingPolicies is a helper method to define mock.On call
//   - ptype string
//   - oldRules [][]string
//   - newRules [][]string
func (_e *MockIEnforcer_Expecter) UpdateNamedGroupingPolicies(ptype interface{}, oldRules interface{}, newRules interface{}) *MockIEnforcer_UpdateNamedGroupingPolicies_Call {
	return &MockIEnforcer_UpdateNamedGroupingPolicies_Call{Call: _e.mock.On("UpdateNamedGroupingPolicies", ptype, oldRules, newRules)}
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicies_Call) Run(run func(ptype string, oldRules [][]string, newRules [][]string)) *MockIEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([][]string), args[2].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicies_Call) RunAndReturn(run func(string, [][]string, [][]string) (bool, error)) *MockIEnforcer_UpdateNamedGroupingPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNamedGroupingPolicy provides a mock function with given fields: ptype, oldRule, newRule
func (_m *MockIEnforcer) UpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error) {
	ret := _m.Called(ptype, oldRule, newRule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNamedGroupingPolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []string, []string) (bool, error)); ok {
		return rf(ptype, oldRule, newRule)
	}
	if rf, ok := ret.Get(0).(func(string, []string, []string) bool); ok {
		r0 = rf(ptype, oldRule, newRule)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, []string, []string) error); ok {
		r1 = rf(ptype, oldRule, newRule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdateNamedGroupingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNamedGroupingPolicy'
type MockIEnforcer_UpdateNamedGroupingPolicy_Call struct {
	*mock.Call
}

// UpdateNamedGroupingPolicy is a helper method to define mock.On call
//   - ptype string
//   - oldRule []string
//   - newRule []string
func (_e *MockIEnforcer_Expecter) UpdateNamedGroupingPolicy(ptype interface{}, oldRule interface{}, newRule interface{}) *MockIEnforcer_UpdateNamedGroupingPolicy_Call {
	return &MockIEnforcer_UpdateNamedGroupingPolicy_Call{Call: _e.mock.On("UpdateNamedGroupingPolicy", ptype, oldRule, newRule)}
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicy_Call) Run(run func(ptype string, oldRule []string, newRule []string)) *MockIEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string), args[2].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdateNamedGroupingPolicy_Call) RunAndReturn(run func(string, []string, []string) (bool, error)) *MockIEnforcer_UpdateNamedGroupingPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicies provides a mock function with given fields: oldPolicies, newPolicies
func (_m *MockIEnforcer) UpdatePolicies(oldPolicies [][]string, newPolicies [][]string) (bool, error) {
	ret := _m.Called(oldPolicies, newPolicies)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([][]string, [][]string) (bool, error)); ok {
		return rf(oldPolicies, newPolicies)
	}
	if rf, ok := ret.Get(0).(func([][]string, [][]string) bool); ok {
		r0 = rf(oldPolicies, newPolicies)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([][]string, [][]string) error); ok {
		r1 = rf(oldPolicies, newPolicies)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdatePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicies'
type MockIEnforcer_UpdatePolicies_Call struct {
	*mock.Call
}

// UpdatePolicies is a helper method to define mock.On call
//   - oldPolicies [][]string
//   - newPolicies [][]string
func (_e *MockIEnforcer_Expecter) UpdatePolicies(oldPolicies interface{}, newPolicies interface{}) *MockIEnforcer_UpdatePolicies_Call {
	return &MockIEnforcer_UpdatePolicies_Call{Call: _e.mock.On("UpdatePolicies", oldPolicies, newPolicies)}
}

func (_c *MockIEnforcer_UpdatePolicies_Call) Run(run func(oldPolicies [][]string, newPolicies [][]string)) *MockIEnforcer_UpdatePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]string), args[1].([][]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdatePolicies_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdatePolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdatePolicies_Call) RunAndReturn(run func([][]string, [][]string) (bool, error)) *MockIEnforcer_UpdatePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicy provides a mock function with given fields: oldPolicy, newPolicy
func (_m *MockIEnforcer) UpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error) {
	ret := _m.Called(oldPolicy, newPolicy)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string) (bool, error)); ok {
		return rf(oldPolicy, newPolicy)
	}
	if rf, ok := ret.Get(0).(func([]string, []string) bool); ok {
		r0 = rf(oldPolicy, newPolicy)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]string, []string) error); ok {
		r1 = rf(oldPolicy, newPolicy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIEnforcer_UpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicy'
type MockIEnforcer_UpdatePolicy_Call struct {
	*mock.Call
}

// UpdatePolicy is a helper method to define mock.On call
//   - oldPolicy []string
//   - newPolicy []string
func (_e *MockIEnforcer_Expecter) UpdatePolicy(oldPolicy interface{}, newPolicy interface{}) *MockIEnforcer_UpdatePolicy_Call {
	return &MockIEnforcer_UpdatePolicy_Call{Call: _e.mock.On("UpdatePolicy", oldPolicy, newPolicy)}
}

func (_c *MockIEnforcer_UpdatePolicy_Call) Run(run func(oldPolicy []string, newPolicy []string)) *MockIEnforcer_UpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].([]string))
	})
	return _c
}

func (_c *MockIEnforcer_UpdatePolicy_Call) Return(_a0 bool, _a1 error) *MockIEnforcer_UpdatePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIEnforcer_UpdatePolicy_Call) RunAndReturn(run func([]string, []string) (bool, error)) *MockIEnforcer_UpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIEnforcer creates a new instance of MockIEnforcer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIEnforcer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIEnforcer {
	mock := &MockIEnforcer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
